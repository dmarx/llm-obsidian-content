---
date: '2025-05-08T23:59:02.637803Z'
tags:
- autogenerated
- source__claude
- conversation_id__9330c349-fe9a-448b-93d1-0e96af457bee
- msg_9b92e760-a160-48a4-b612-2177c3030bee
- msg_b47cd7c1-3816-4014-ae0e-4c66def1d433
- colorclass/philosophy-of-language
title: lambda calculus
---

**USER**

lambda calculus


**ASSISTANT**

# Lambda Calculus

Lambda calculus is a formal system in [[mathematical logic]] for expressing [[computation]] based on [[function abstraction]] and [[application]]. Developed by [[Alonzo Church]] in the 1930s, it forms the theoretical foundation for [[functional programming]] languages and provides a framework for studying the notion of [[computability]].

## Core Concepts

### Syntax

The syntax of the lambda calculus consists of three kinds of expressions (also called 位-terms):

1. **Variables**: Typically denoted by lowercase letters (e.g., $x$, $y$, $z$)
2. **Abstractions**: Written as $\lambda x.M$ where $x$ is a variable and $M$ is another 位-term
3. **Applications**: Written as $(M \, N)$ where $M$ and $N$ are 位-terms

Formally, the set of 位-terms, $\Lambda$, can be defined inductively:
- If $x$ is a variable, then $x \in \Lambda$
- If $x$ is a variable and $M \in \Lambda$, then $(\lambda x.M) \in \Lambda$
- If $M, N \in \Lambda$, then $(M \, N) \in \Lambda$

### Semantics

The semantics of lambda calculus is based on two key operations:

1. **Alpha-conversion** ($\alpha$-conversion): Renaming bound variables
   - $\lambda x.M \equiv_\alpha \lambda y.M[x/y]$ if $y$ is not free in $M$

2. **Beta-reduction** ($\beta$-reduction): Applying a function to an argument
   - $(\lambda x.M) \, N \to_\beta M[x:=N]$ where $M[x:=N]$ means substituting $N$ for all free occurrences of $x$ in $M$

A term with no possible $\beta$-reductions is in **beta normal form**.

### Free and Bound Variables

- A variable $x$ is **bound** in a term if it appears within the scope of a $\lambda x$
- A variable is **free** if it is not bound
- For example, in $\lambda x.(\lambda y.(x \, y) \, z)$, $x$ and $y$ are bound, while $z$ is free

## Church Encodings

[[Church encoding]] is a representation of data and operators using only functions. Some fundamental encodings include:

### Booleans

- **True**: $\lambda x.\lambda y.x$
- **False**: $\lambda x.\lambda y.y$
- **AND**: $\lambda p.\lambda q.(p \, q \, p)$
- **OR**: $\lambda p.\lambda q.(p \, p \, q)$
- **NOT**: $\lambda p.(p \, (\lambda x.\lambda y.y) \, (\lambda x.\lambda y.x))$

### Natural Numbers (Church Numerals)

Church numerals represent natural numbers as functions that apply a function $n$ times:

- $0 := \lambda f.\lambda x.x$
- $1 := \lambda f.\lambda x.(f \, x)$
- $2 := \lambda f.\lambda x.(f \, (f \, x))$
- $n := \lambda f.\lambda x.f^n(x)$

Arithmetic operations:
- **Successor**: $\lambda n.\lambda f.\lambda x.f \, (n \, f \, x)$
- **Addition**: $\lambda m.\lambda n.\lambda f.\lambda x.(m \, f \, (n \, f \, x))$
- **Multiplication**: $\lambda m.\lambda n.\lambda f.(m \, (n \, f))$
- **Exponentiation**: $\lambda m.\lambda n.(n \, m)$

### Pairs and Lists

- **Pair**: $\lambda x.\lambda y.\lambda f.(f \, x \, y)$
- **First**: $\lambda p.(p \, (\lambda x.\lambda y.x))$
- **Second**: $\lambda p.(p \, (\lambda x.\lambda y.y))$
- **Nil** (empty list): $\lambda x.True$
- **Cons**: $\lambda h.\lambda t.\lambda s.(s \, h \, t)$

## Computational Properties

### Fixed-Point Combinators

The [[Y combinator]] allows for the definition of recursive functions:

$Y := \lambda f.(\lambda x.(f \, (x \, x)) \, \lambda x.(f \, (x \, x)))$

For any function $F$, $Y \, F$ is a fixed point of $F$, meaning $Y \, F = F \, (Y \, F)$.

### Church-Rosser Theorem

The [[Church-Rosser theorem]] states that if a term $M$ can be reduced to two different terms $N_1$ and $N_2$, then there exists a term $P$ such that both $N_1$ and $N_2$ can be reduced to $P$.

This property, known as [[confluence]], ensures that the order of evaluation doesn't affect the final result, assuming termination.

### Turing Completeness

Lambda calculus is [[Turing complete]], meaning it can represent any [[computable function]]. This equivalence with [[Turing machines]] was established by [[Alan Turing]] and forms the basis of the [[Church-Turing thesis]].

## Lambda Calculi Variants

### Simply Typed Lambda Calculus

The [[simply typed lambda calculus]] (STLC) extends the untyped calculus with types to ensure certain properties:
- Every well-typed term has a normal form (normalization)
- Evaluation always terminates (strong normalization)

Type syntax:
- Base types: $\tau$
- Function types: $\sigma \rightarrow \tau$

### System F (Polymorphic Lambda Calculus)

[[System F]] introduces parametric polymorphism, allowing abstraction over types:
$\Lambda \alpha.M$ where $\alpha$ is a type variable and $M$ is a term.

### Dependent Type Theory

In [[dependent type theory]], types can depend on values, enabling more expressive type systems used in [[proof assistants]] like [[Coq]] and [[Agda]].

## Connections to Computer Science

Lambda calculus has profound connections to computer science:
- Forms the theoretical basis for [[functional programming]] languages like [[Haskell]], [[ML]], and [[Lisp]]
- Provides a framework for studying [[type systems]]
- Underlies the implementation of [[lazy evaluation]]
- Connects to [[category theory]] through the [[Curry-Howard isomorphism]]
- Serves as a model for [[higher-order logic]]

## Formal Notation

We can define a formal notation for lambda calculus as follows:

$\begin{align}
\text{Terms } t &::= x \mid \lambda x.t \mid t_1 \, t_2 \\
\text{Values } v &::= \lambda x.t
\end{align}$

The operational semantics can be given by the following evaluation rules:

$\frac{t_1 \to t_1'}{t_1 \, t_2 \to t_1' \, t_2} \quad \frac{t_1 \text{ is a value } \quad t_2 \to t_2'}{t_1 \, t_2 \to t_1 \, t_2'} \quad \frac{}{(\lambda x.t_1) \, v_2 \to t_1[x := v_2]}$

where $t_1[x := v_2]$ represents the substitution of $v_2$ for all free occurrences of $x$ in $t_1$.


---


following: [[beta reduction]]

See also: [[seminal works in the development of type theory]]


See also: [[formal semantics]]


See also: [[montague grammar]]


See also: [[intensional type theory]]


See also: [[seminal works in the development of the theory of programming languages]]


See also: [[synthesize (pattern)]]


See also: [[bend framework]]


See also: [[type theory]]


See also: [[operational semantics]]


See also: [[interaction combinators]]