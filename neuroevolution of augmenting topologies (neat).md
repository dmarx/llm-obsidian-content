---
date: 1717291884.726301
tags:
- autogenerated
- source__oai
- conversation_id__ca65c423-5293-48ca-a72e-29630dbc5375
- msg_aaa23799-6ade-400d-afc0-23dced30133c
- msg_86ee2d14-e5e3-48e0-8035-00a567cf2cc3
- colorclass/decision-making-processes
title: neuroevolution of augmenting topologies (neat)
---

**USER**

Neuroevolution of augmenting topologies


**ASSISTANT**

## Neuroevolution of Augmenting Topologies (NEAT)

### Overview

Neuroevolution of Augmenting Topologies (NEAT) is an evolutionary algorithm designed to evolve artificial neural networks (ANNs). Unlike traditional [[neuroevolution]] methods that optimize fixed-topology networks, NEAT dynamically evolves both the weights and the structure (topology) of the network. This approach allows NEAT to start with simple networks and gradually complexify them by adding new nodes and connections, enabling the discovery of increasingly sophisticated neural architectures.

### Key Concepts

1. **Genotype Representation**: NEAT represents neural networks as directed graphs encoded by a genotype comprising nodes and connection genes.
2. **Mutation Operations**: NEAT uses specific mutation operations to alter both the structure and weights of neural networks.
3. **Speciation**: NEAT groups similar networks into species to protect innovation and promote diversity.
4. **Fitness Sharing**: Fitness sharing within species prevents any one species from dominating the population, maintaining diversity.
5. **Complexification**: Starting with simple networks, NEAT progressively complexifies the network topology by adding nodes and connections.

### Genotype Representation

NEAT encodes neural networks using a direct representation, where each network is described by a list of nodes and connections:

- **Node Genes**: Represent neurons, identified by unique IDs.
- **Connection Genes**: Represent directed connections between nodes, specified by innovation numbers to track historical origin.

#### Example

A simple network genotype might look like this:

- **Node Genes**: {1 (input), 2 (output), 3 (hidden)}
- **Connection Genes**: {(1 → 2), (1 → 3), (3 → 2)}

### Mutation Operations

1. **Add Connection Mutation**: Adds a new connection between two previously unconnected nodes.
2. **Add Node Mutation**: Splits an existing connection by adding a new node, creating two new connections.
3. **Weight Mutation**: Perturbs the weight of an existing connection.

#### Formalization

Let \( \mathbf{N} \) represent the set of nodes and \( \mathbf{C} \) the set of connections. The mutation operations can be defined as:

- **Add Connection**: \( \mathbf{C}' = \mathbf{C} \cup \{(i, j, w)\} \) where \( i, j \in \mathbf{N} \) and \( w \) is a random weight.
- **Add Node**: For a connection \( (i, j, w) \in \mathbf{C} \), replace it with \( (i, k, w_1) \) and \( (k, j, w_2) \), where \( k \) is a new node and \( w_1, w_2 \) are new weights.
- **Weight Mutation**: For \( (i, j, w) \in \mathbf{C} \), update the weight \( w \) to \( w' = w + \Delta w \) where \( \Delta w \) is a small random perturbation.

### Speciation

NEAT uses speciation to maintain diversity by grouping similar networks into species. Speciation protects new structural innovations by allowing them to evolve within their own niches.

#### Compatibility Distance

The compatibility distance \( \delta \) between two genomes \( g_1 \) and \( g_2 \) is defined as:

$$
\delta = \frac{c_1 E}{N} + \frac{c_2 D}{N} + c_3 \bar{W}
$$

where:

- \( E \) is the number of excess genes.
- \( D \) is the number of disjoint genes.
- \( \bar{W} \) is the average weight difference of matching genes.
- \( N \) is the number of genes in the larger genome.
- \( c_1, c_2, c_3 \) are coefficients.

### Fitness Sharing

Within each species, fitness sharing ensures that the reproductive potential of each individual is reduced in proportion to the number of individuals in its species. This prevents any single species from dominating the population and maintains diversity.

### Complexification

NEAT starts with a simple network structure and gradually complexifies it through mutation operations. This incremental growth allows NEAT to effectively explore the search space by building on existing solutions.

### Algorithmic Steps

1. **Initialization**: Begin with a population of simple networks.
2. **Evaluation**: Compute the fitness of each network based on the problem-specific fitness function.
3. **Speciation**: Group networks into species based on compatibility distance.
4. **Selection**: Select parent networks from each species, biased by fitness.
5. **Crossover**: Combine pairs of parent networks to produce offspring.
6. **Mutation**: Apply mutation operations to offspring networks.
7. **Replacement**: Form a new population by selecting the best networks from the parents and offspring.
8. **Termination**: Repeat the evaluation-speciation-selection-crossover-mutation-replacement cycle until a stopping criterion is met, such as a maximum number of generations or a satisfactory fitness level.

### Applications

NEAT is used in various fields, including:

- **Robotics**: Evolving control policies and behaviors for autonomous robots.
- **Game Playing**: Developing strategies and behaviors for artificial players.
- **Function Approximation**: Creating neural networks for regression and classification tasks.
- **Design Optimization**: Evolving network architectures for specific engineering problems.

### Conclusion

NEAT's ability to evolve both the topology and weights of neural networks makes it a powerful and flexible approach to [[neuroevolution]]. By maintaining diversity through speciation and allowing incremental complexification, NEAT effectively explores the search space and discovers sophisticated network architectures.

For further exploration, you might want to delve into related topics such as [[Genotype Representation in NEAT]], [[Mutation Operations in NEAT]], and [[Speciation and Fitness Sharing in NEAT]].


---

preceding: [[mutation in [[evolutionary strategies]]]]  


following: [[compatibility distance in neat]]

See also: [[neuroevolution]]