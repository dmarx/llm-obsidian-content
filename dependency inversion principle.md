---
date: 1727917203.208986
tags:
- autogenerated
- source__oai
- conversation_id__66fdeb95-c32c-8008-9a23-d10da96b1985
- msg_e04be430-0f17-4655-ba80-6edbd24d4cff
- msg_daaff884-51bd-401d-ab50-e9b93499bd0c
- colorclass/edge-case
title: dependency inversion principle
---

**USER**

dependency inversion principle


**ASSISTANT**

The **Dependency Inversion Principle (DIP)** is the 'D' in the SOLID principles of object-oriented design. It asserts that **high-level modules should not depend on low-level modules. Both should depend on abstractions.** Furthermore, **abstractions should not depend on details; details should depend on abstractions.** This principle promotes flexibility, modularity, and ease of maintenance in software design by reversing the traditional dependency direction.

## Formal Definition of DIP

The Dependency Inversion Principle can be summarized in two key points:

1. **High-Level Modules:** These should not directly depend on low-level modules. Both should rely on abstractions (e.g., interfaces or abstract classes).
2. **Abstractions:** Should not depend on concrete details. Instead, it is the specific implementations (details) that should depend on the abstractions.

By adhering to DIP, a software system becomes more resilient to change, since the high-level policies are decoupled from the low-level details. This enables easier substitution, testing, and extension of software components.

## Why Use DIP?

The primary motivation for the Dependency Inversion Principle is to achieve a system design where the policy of a system (the high-level modules) is not affected by changes in its low-level details (e.g., how data is stored, how network requests are handled). It also allows different implementations to be swapped out with minimal impact on the overall system.

### Benefits

1. **Loose Coupling:** High-level modules don't need to be concerned with specific implementations, promoting modular and flexible code.
2. **Testability:** By depending on abstractions (e.g., interfaces), high-level modules can be tested independently using mock implementations.
3. **Scalability and Maintainability:** Changes to low-level modules do not force changes to high-level modules, making the system easier to maintain and extend.

## How to Implement DIP

DIP is typically implemented using **interfaces** or **abstract classes** to define abstractions and then injecting concrete implementations at runtime. This is often facilitated by patterns like **Dependency Injection** and **Factory Method**.

### Example: Violation of DIP

Consider a `UserService` class that directly depends on a concrete `Database` class for user data storage.

#### Code without DIP

```python
class Database:
    def save(self, data):
        print(f"Saving {data} to the database")

class UserService:
    def __init__(self):
        self.database = Database()
    
    def store_user(self, user):
        self.database.save(user)
```

In this design:
- The `UserService` (high-level module) directly depends on the `Database` (low-level module).
- If the database implementation changes (e.g., switching to a different database), the `UserService` needs to be modified, violating the Dependency Inversion Principle.

### Example: Applying DIP

To apply DIP, we first define an abstraction (`DataRepository`) that `UserService` will depend on. Then, we provide the concrete `Database` implementation at runtime.

#### Step 1: Define an Abstraction

```python
from abc import ABC, abstractmethod

class DataRepository(ABC):
    @abstractmethod
    def save(self, data):
        pass
```

#### Step 2: Implement the Abstraction

```python
class Database(DataRepository):
    def save(self, data):
        print(f"Saving {data} to the database")
```

#### Step 3: Modify the High-Level Module to Rely on the Abstraction

```python
class UserService:
    def __init__(self, repository: DataRepository):
        self.repository = repository

    def store_user(self, user):
        self.repository.save(user)
```

#### Step 4: Inject the Dependency

```python
database = Database()  # Low-level module
user_service = UserService(database)  # High-level module depends on an abstraction
user_service.store_user("John Doe")
```

Now, the `UserService` depends on the `DataRepository` abstraction rather than a specific `Database` implementation. This enables flexibility in swapping out the data storage mechanism (e.g., using an in-memory store, a file, or a different database) without modifying the `UserService`.

### Example: Switching to a Different Implementation

If we need to switch to an in-memory storage implementation, we simply create a new class that implements `DataRepository`:

```python
class InMemoryRepository(DataRepository):
    def __init__(self):
        self.data_store = []

    def save(self, data):
        self.data_store.append(data)
        print(f"Saved {data} in memory")
```

And we can inject this new implementation into `UserService`:

```python
in_memory_repo = InMemoryRepository()
user_service = UserService(in_memory_repo)
user_service.store_user("Jane Doe")
```

## Key Concepts and Related Patterns

- **[[Dependency Injection]]:** A way to provide dependencies to a class, often used to achieve DIP. Dependencies are injected into classes rather than being instantiated within them.
- **[[Adapter Pattern]]:** Helps in creating an abstraction layer over different implementations, allowing high-level modules to depend on abstractions.
- **Inversion of Control (IoC):** A broader concept that encompasses DIP, where the control of object creation and flow is inverted and handled by an external entity (often an IoC container).

## When to Use DIP

- When designing **flexible and modular software**, especially in large-scale systems where different parts of the application might need to change independently.
- When building **testable software** by allowing mock implementations to be injected into components for unit testing.
- In systems that need to **support multiple implementations** of the same functionality (e.g., different data storage backends).

By following the **Dependency Inversion Principle**, software systems become more modular, adaptable to change, and easier to test and maintain. This principle decouples high-level logic from the low-level details, leading to a more flexible and scalable codebase.


---

preceding: [[single responsibility principle]]  


following: [[solid principles]]

See also: [[unit testing]]