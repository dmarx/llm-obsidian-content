---
date: 1715214482.314096
tags:
- autogenerated
- source__oai
- conversation_id__fd57d9bc-a00e-49b6-a4d6-1a6349f97e18
- msg_aaa295e9-b6ff-4cde-8832-361fe9583923
- msg_85b64c5d-9c78-4569-ad17-8fc673278de6
- colorclass/reference-frame
title: either monad
---

**USER**

the Either monad


**ASSISTANT**

The **Either monad** is a powerful concept in [[Functional Programming]] used to represent a value that can be of one of two possible types. It's a type of algebraic data type, typically used for error handling where the `Left` type is traditionally used to hold an error or a failure case, while the `Right` type usually contains a successful value. The naming convention (`Left` and `Right`) does not impose any intrinsic meaning, but by convention, `Right` is considered the "correct" or "successful" path, and `Left` is used for "errors" or "exceptions".

### Formal Definition

The `Either` type can be defined as:

$$ Either \, A \, B = Left \, A \, | \, Right \, B $$

Here, `A` and `B` are types, and an `Either` can be either a `Left` holding a value of type `A`, or a `Right` holding a value of type `B`. This structure allows functions to return an `Either` type where the caller must handle both success and failure explicitly, improving the robustness and clarity of error handling.

### Monad Properties

As a monad, `Either` adheres to the following monadic properties:

1. **Identity (Return):** The `return` operation for `Either` monad typically injects a value into the `Right` type.
   $$ \text{return} \, x = Right \, x $$

2. **Bind (>>=):** The `bind` operation (`>>=`), which is central to monad behavior, handles the chaining of operations that return `Either` types. It only continues the computation if the value is `Right`; otherwise, it short-circuits and returns `Left`.
   $$ Either \, A \, B \rightarrow (B \rightarrow Either \, A \, C) \rightarrow Either \, A \, C $$
   $$ m \, >>= \, f = \text{case} \, m \, \text{of} $$
   $$ \quad \quad Left \, x \rightarrow Left \, x $$
   $$ \quad \quad Right \, y \rightarrow f(y) $$

This means if `m` is `Left x`, then the result is `Left x` (propagating the error). If `m` is `Right y`, then `f(y)` is applied, potentially leading to another `Either`.

### Practical Use

In practical terms, the `Either` monad allows developers to write cleaner code by encapsulating error handling directly within the flow of data and operations. This approach avoids exceptions and instead uses type-safe error propagation that must be explicitly handled, reducing the likelihood of overlooked errors.

For example, in a function that parses integers from strings and performs arithmetic, using `Either` can clearly separate the error handling (like parsing errors) from the main logic:

```haskell
parseAndDivide :: String -> String -> Either String Int
parseAndDivide numStr denomStr =
    parse numStr >>= \num ->
    parse denomStr >>= \denom ->
    if denom == 0
        then Left "Division by zero error"
        else Right (num `div` denom)

parse :: String -> Either String Int
parse str = case reads str of
    [(num, "")] -> Right num
    _           -> Left "Parse error"
```

In this example, if any `parse` call fails, the computation short-circuits, returning a `Left` with an error message. If all goes well, the division is checked and computed or another error is returned. Each step handles its part of the flow, making the code modular and robust.

### Conclusion

The `Either` monad offers a structured way to handle errors and other dual-outcome scenarios in functional programming, making error handling a fundamental part of the type system rather than an afterthought. This approach not only improves software reliability but also aligns with functional programming's principles of immutability and pure function use.


---

preceding: [[how do the themes that underlie the unix philosophy and the robustness principle tie into the principles of functional programming]]  


following: [[the [[bind operation (=) is central to monad behavior]]]]

See also: [[error propagation]]