---
date: '2025-05-27T05:05:43.010700Z'
tags:
- autogenerated
- source__claude
- conversation_id__2ca046e4-6d55-4c0f-8974-cd241ab7121b
- msg_4fc49dde-30fc-456b-97e1-f4ccb66ec6ad
- msg_fcd955ba-e528-4f1e-99a4-e10bc0febe18
- colorclass/philosophy-of-language
title: intensional type theory
---

**USER**

Intensional Type Theory


**ASSISTANT**

# [[Intensional Type Theory]]

**Intensional Type Theory** (ITT) constitutes a foundational framework combining [[dependent types]], [[constructive logic]], and [[computational content]] where type equality is determined by [[definitional equivalence]] rather than [[extensional equality]]. ITT serves as the theoretical basis for [[proof assistants]], [[constructive mathematics]], and [[homotopy type theory]].

## Foundational Structure

ITT extends [[simply typed lambda calculus]] with [[dependent function types]] $\Pi x:A.B(x)$ and [[dependent pair types]] $\Sigma x:A.B(x)$. The type system includes:

- **Type universes**: $\mathcal{U}_0 : \mathcal{U}_1 : \mathcal{U}_2 : \cdots$
- **Dependent functions**: $\Pi x:A.B(x)$ (generalizing $A \to B$)
- **Dependent pairs**: $\Sigma x:A.B(x)$ (generalizing $A \times B$)
- **Identity types**: $\text{Id}_A(a,b)$ expressing [[propositional equality]]
- **Inductive types**: $\mathbb{N}, \text{List}(A), \text{Tree}(A)$

The [[typing judgment]] $\Gamma \vdash t : A$ asserts that term $t$ has type $A$ in context $\Gamma$.

## [[Martin-Löf]] Type Theory Formulation

### Formation Rules
Types are formed according to [[inference rules]]:

$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma, x:A \vdash B(x) : \mathcal{U}_j}{\Gamma \vdash \Pi x:A.B(x) : \mathcal{U}_{\max(i,j)}} \Pi\text{-form}$$

$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma, x:A \vdash B(x) : \mathcal{U}_j}{\Gamma \vdash \Sigma x:A.B(x) : \mathcal{U}_{\max(i,j)}} \Sigma\text{-form}$$

### Introduction Rules
Terms of dependent types are constructed via:

$$\frac{\Gamma, x:A \vdash b(x) : B(x)}{\Gamma \vdash \lambda x.b(x) : \Pi x:A.B(x)} \Pi\text{-intro}$$

$$\frac{\Gamma \vdash a : A \quad \Gamma \vdash b : B(a)}{\Gamma \vdash (a,b) : \Sigma x:A.B(x)} \Sigma\text{-intro}$$

### Elimination Rules
Terms are eliminated through [[application]] and [[projection]]:

$$\frac{\Gamma \vdash f : \Pi x:A.B(x) \quad \Gamma \vdash a : A}{\Gamma \vdash f(a) : B(a)} \Pi\text{-elim}$$

$$\frac{\Gamma \vdash p : \Sigma x:A.B(x)}{\Gamma \vdash \pi_1(p) : A} \Sigma\text{-elim}_1$$

$$\frac{\Gamma \vdash p : \Sigma x:A.B(x)}{\Gamma \vdash \pi_2(p) : B(\pi_1(p))} \Sigma\text{-elim}_2$$

## [[Intensional vs Extensional]] Distinction

### Intensional Identity
In ITT, [[propositional equality]] $\text{Id}_A(a,b)$ is distinct from [[definitional equality]] $a \equiv b$. Two functions $f, g : \Pi x:A.B(x)$ are intensionally equal only if:
$$\text{Id}_{\Pi x:A.B(x)}(f,g) \text{ is inhabited}$$

This contrasts with [[extensional type theory]] where [[function extensionality]] holds:
$$\left(\Pi x:A.\text{Id}_{B(x)}(f(x),g(x))\right) \to \text{Id}_{\Pi x:A.B(x)}(f,g)$$

### [[Computational Content]]
ITT preserves [[algorithmic information]] within proofs. A proof of $\Pi x:A.B(x)$ contains a [[computable function]] witnessing the universal quantification, not merely its existence.

## [[Identity Types]] and [[Path Induction]]

The [[identity type]] $\text{Id}_A(a,b)$ represents [[propositional equality]] with formation rule:
$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma \vdash a : A \quad \Gamma \vdash b : A}{\Gamma \vdash \text{Id}_A(a,b) : \mathcal{U}_i}$$

Introduction via [[reflexivity]]:
$$\frac{\Gamma \vdash a : A}{\Gamma \vdash \text{refl}_a : \text{Id}_A(a,a)}$$

The elimination principle ([[J-rule]] or [[path induction]]) states:
$$\frac{\begin{array}{c}
\Gamma, x:A, y:A, p:\text{Id}_A(x,y) \vdash C(x,y,p) : \mathcal{U}_i \\
\Gamma, z:A \vdash d(z) : C(z,z,\text{refl}_z) \\
\Gamma \vdash a : A \quad \Gamma \vdash b : A \quad \Gamma \vdash q : \text{Id}_A(a,b)
\end{array}}{\Gamma \vdash J(d,q) : C(a,b,q)}$$

## [[Inductive Types]] and [[Recursion Principles]]

### Natural Numbers
The type $\mathbb{N}$ is defined inductively with constructors:
- $0 : \mathbb{N}$
- $\text{succ} : \mathbb{N} \to \mathbb{N}$

The [[recursion principle]] enables definition of functions $f : \mathbb{N} \to C$:
$$\text{rec}_{\mathbb{N}} : \Pi C:\mathcal{U}. C \to (C \to C) \to \mathbb{N} \to C$$

with computation rules:
$$\text{rec}_{\mathbb{N}}(C,c_0,c_s,0) \equiv c_0$$
$$\text{rec}_{\mathbb{N}}(C,c_0,c_s,\text{succ}(n)) \equiv c_s(\text{rec}_{\mathbb{N}}(C,c_0,c_s,n))$$

### [[Induction-Recursion]]
ITT supports simultaneous definition of types and functions, enabling [[universe construction]]:
$$\frac{\Gamma \vdash \mathcal{U} : \text{Type} \quad \Gamma \vdash T : \mathcal{U} \to \text{Type}}{\Gamma \vdash (\mathcal{U}, T) : \text{IR-Type}}$$

## [[Propositions as Types]] ([[Curry-Howard]] Correspondence)

ITT embodies the [[propositions-as-types]] principle where:
- **Propositions** correspond to **types**
- **Proofs** correspond to **terms**
- **Proof normalization** corresponds to **computation**

Logical connectives translate as:
$$\begin{align}
A \land B &\leftrightarrow A \times B \\
A \lor B &\leftrightarrow A + B \\
A \to B &\leftrightarrow A \to B \\
\forall x:A.B(x) &\leftrightarrow \Pi x:A.B(x) \\
\exists x:A.B(x) &\leftrightarrow \Sigma x:A.B(x)
\end{align}$$

## [[Homotopy Type Theory]] Extension

[[Homotopy Type Theory]] (HoTT) reinterprets ITT through [[topological intuition]]:
- **Types** as [[topological spaces]]
- **Terms** as [[points]]
- **Identity types** as [[path spaces]]
- **Higher identity types** as [[homotopies]]

The [[univalence axiom]] asserts:
$$\text{(Type equivalence)} \simeq \text{(Type equality)}$$

Formally: $\text{ua} : \Pi A,B:\mathcal{U}. (A \simeq B) \to \text{Id}_{\mathcal{U}}(A,B)$

## [[Higher Inductive Types]]

HoTT introduces [[higher inductive types]] (HITs) with [[path constructors]]:

### Circle $S^1$
$$\begin{align}
&\text{base} : S^1 \\
&\text{loop} : \text{Id}_{S^1}(\text{base}, \text{base})
\end{align}$$

### [[Pushout]]
For functions $f : C \to A$ and $g : C \to B$:
$$\begin{align}
&\text{inl} : A \to A \sqcup_C B \\
&\text{inr} : B \to A \sqcup_C B \\
&\text{glue} : \Pi c:C. \text{Id}_{A \sqcup_C B}(\text{inl}(f(c)), \text{inr}(g(c)))
\end{align}$$

## [[Computational Interpretation]]

### [[Weak Head Normal Form]]
ITT terms evaluate to [[weak head normal form]] (WHNF) where the outermost constructor is exposed:
$$\lambda x.t, \; \text{succ}(n), \; (a,b), \; \text{inl}(a)$$

### [[Strong Normalization]]
ITT enjoys [[strong normalization]]: all reduction sequences terminate. This ensures [[decidability]] of [[type checking]] and [[definitional equality]].

The [[logical consistency]] follows from strong normalization via the fact that no closed term inhabits the [[empty type]] $\bot$.

## [[Cubical Type Theory]]

[[Cubical Type Theory]] provides [[computational content]] for univalence through:
- **Cubical sets** as [[semantic model]]
- **Interval type** $I$ with endpoints $0, 1 : I$
- **Path types** $\text{Path}_A(a,b) = (I \to A) \text{ with boundaries } a, b$

[[Transport]] along paths enables computational univalence:
$$\text{transport} : \Pi A,B:\mathcal{U}. \text{Path}_{\mathcal{U}}(A,B) \to A \to B$$

## [[Modal Type Theory]]

ITT extends to [[modal contexts]] with [[contextual modal operators]]:
- $\square A$: "necessarily $A$"
- $\text{next } A$: "$A$ at the next stage"
- $\bigcirc A$: "$A$ later"

[[Staged computation]] uses modal types for [[partial evaluation]]:
$$\text{code} : \text{Type} \to \text{Type}$$
$$\text{splice} : \Pi A:\text{Type}. \text{code}(A) \to A$$

## [[Realizability Semantics]]

ITT admits [[realizability interpretation]] where:
- Types are interpreted as [[partial equivalence relations]] (PERs)
- Terms are interpreted as [[computable functions]]
- The [[realizability relation]] $n \Vdash A$ means "number $n$ realizes type $A$"

For dependent functions:
$$n \Vdash \Pi x:A.B(x) \iff \forall m. (m \Vdash A \to n \cdot m \Vdash B(\ulcorner m \urcorner))$$

## [[Categorical Semantics]]

ITT interprets in [[locally Cartesian closed categories]] with:
- **Context extension** as [[pullback]]
- **Dependent functions** as [[right adjoints]] to [[weakening]]
- **Identity types** as [[path objects]]

The [[initiality conjecture]] states that the [[syntactic category]] of ITT is [[initial]] among [[locally Cartesian closed categories]] with certain structure.

## Applications in [[Proof Assistants]]

### [[Coq]]
Coq implements the [[Calculus of Inductive Constructions]] extending ITT with:
- **Impredicative** $\text{Prop}$ universe
- **Coinductive types** for infinite structures
- **Module system** for large-scale development

### [[Agda]]
Agda provides ITT with:
- **Universe polymorphism** $\text{Set}_\ell$ for level $\ell$
- **Pattern matching** on inductive families
- **Sized types** for [[termination checking]]

### [[Lean]]
Lean implements ITT with:
- **Classical reasoning** via [[choice axiom]]
- **Type classes** for [[ad-hoc polymorphism]]
- **Tactic mode** for interactive proving

## Related Concepts

- [[Dependent Types]]
- [[Constructive Logic]]
- [[Curry-Howard Correspondence]]
- [[Homotopy Type Theory]]
- [[Martin-Löf Type Theory]]
- [[Proof Assistants]]
- [[Categorical Logic]]
- [[Higher Inductive Types]]
- [[Univalence Axiom]]
- [[Cubical Type Theory]]


---

preceding: [[modal logic]]  


following: [[martin-löf type theory]]

See also: [[lambda calculus]]


See also: [[type theory]]