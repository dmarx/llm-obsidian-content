---
date: '2025-05-27T05:07:38.266211Z'
tags:
- autogenerated
- source__claude
- conversation_id__2ca046e4-6d55-4c0f-8974-cd241ab7121b
- msg_0f8acd6e-0d40-4d39-8d37-2e7e344e807e
- msg_a377985f-3e13-49bf-a9d4-503b6eb26cb1
- colorclass/philosophy-of-language
title: martin-löf type theory
---

**USER**

Martin-Löf Type Theory


**ASSISTANT**

# [[Martin-Löf Type Theory]]

**Martin-Löf Type Theory** (MLTT) constitutes the foundational [[constructive type theory]] developed by Per Martin-Löf, providing a unified framework for [[constructive mathematics]], [[programming languages]], and [[formal logic]]. MLTT serves as the theoretical foundation for modern [[proof assistants]] and embodies the [[constructive interpretation]] of mathematical reasoning through the [[propositions-as-types]] correspondence.

## Historical Development and Philosophical Foundations

MLTT emerged from Martin-Löf's program to develop a [[constructive foundation]] for mathematics that avoids [[non-constructive principles]] such as the [[law of excluded middle]] and the [[axiom of choice]]. The theory underwent several iterations:

- **MLTT-72**: Initial version with [[type-in-type]], leading to [[Girard's paradox]]
- **MLTT-79**: Introduction of [[predicative universe hierarchy]]
- **MLTT-84**: Addition of [[W-types]] and refinement of [[identity types]]

The theory embodies [[meaning explanations]] where types are explained in terms of their [[canonical elements]] and [[equality conditions]].

## Core Type Formers

### [[Universe Hierarchy]]
MLTT employs a [[predicative hierarchy]] of type universes to avoid [[Russell's paradox]]:
$$\mathcal{U}_0 : \mathcal{U}_1 : \mathcal{U}_2 : \cdots$$

Each universe $\mathcal{U}_i$ contains types of [[universe level]] $i$, with the constraint:
$$\text{If } A : \mathcal{U}_i \text{ and } B : \mathcal{U}_j, \text{ then } A \to B : \mathcal{U}_{\max(i,j)}$$

### [[Dependent Function Types]] ($\Pi$-types)
The dependent function type $\Pi x:A.B(x)$ generalizes ordinary function types $A \to B$:

**Formation**: 
$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma, x:A \vdash B(x) : \mathcal{U}_j}{\Gamma \vdash \Pi x:A.B(x) : \mathcal{U}_{\max(i,j)}}$$

**Introduction**: 
$$\frac{\Gamma, x:A \vdash b(x) : B(x)}{\Gamma \vdash \lambda x.b(x) : \Pi x:A.B(x)}$$

**Elimination**: 
$$\frac{\Gamma \vdash f : \Pi x:A.B(x) \quad \Gamma \vdash a : A}{\Gamma \vdash f(a) : B(a)}$$

**Computation**: 
$$(\lambda x.b(x))(a) \equiv b(a)$$

### [[Dependent Pair Types]] ($\Sigma$-types)
The dependent pair type $\Sigma x:A.B(x)$ generalizes cartesian products:

**Formation**: 
$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma, x:A \vdash B(x) : \mathcal{U}_j}{\Gamma \vdash \Sigma x:A.B(x) : \mathcal{U}_{\max(i,j)}}$$

**Introduction**: 
$$\frac{\Gamma \vdash a : A \quad \Gamma \vdash b : B(a)}{\Gamma \vdash (a,b) : \Sigma x:A.B(x)}$$

**Elimination**: 
$$\frac{\Gamma \vdash p : \Sigma x:A.B(x)}{\Gamma \vdash \text{fst}(p) : A} \quad \frac{\Gamma \vdash p : \Sigma x:A.B(x)}{\Gamma \vdash \text{snd}(p) : B(\text{fst}(p))}$$

**Computation**: 
$$\text{fst}((a,b)) \equiv a \quad \text{snd}((a,b)) \equiv b$$

### [[Identity Types]] (Equality Types)
Identity types $\text{Id}_A(a,b)$ express [[propositional equality]]:

**Formation**: 
$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma \vdash a : A \quad \Gamma \vdash b : A}{\Gamma \vdash \text{Id}_A(a,b) : \mathcal{U}_i}$$

**Introduction**: 
$$\frac{\Gamma \vdash a : A}{\Gamma \vdash \text{refl}_a : \text{Id}_A(a,a)}$$

**Elimination** ([[J-eliminator]]):
$$\frac{\begin{array}{c}
\Gamma, x:A, y:A, p:\text{Id}_A(x,y) \vdash C(x,y,p) : \mathcal{U}_i \\
\Gamma, z:A \vdash d(z) : C(z,z,\text{refl}_z) \\
\Gamma \vdash a : A \quad \Gamma \vdash b : A \quad \Gamma \vdash q : \text{Id}_A(a,b)
\end{array}}{\Gamma \vdash J(C,d,a,b,q) : C(a,b,q)}$$

**Computation**: 
$$J(C,d,a,a,\text{refl}_a) \equiv d(a)$$

## [[Inductive Types]] and [[Elimination Principles]]

### [[Natural Numbers]]
The inductive type $\mathbb{N}$ with constructors:
- $0 : \mathbb{N}$
- $\text{succ} : \mathbb{N} \to \mathbb{N}$

**Elimination principle** ([[primitive recursion]]):
$$\text{natrec} : \Pi C:\mathcal{U}. C \to (C \to C) \to \mathbb{N} \to C$$

**Computation rules**:
$$\text{natrec}(C,c_0,c_s,0) \equiv c_0$$
$$\text{natrec}(C,c_0,c_s,\text{succ}(n)) \equiv c_s(\text{natrec}(C,c_0,c_s,n))$$

### [[List Types]]
For type $A$, the list type $\text{List}(A)$ with constructors:
- $\text{nil} : \text{List}(A)$
- $\text{cons} : A \to \text{List}(A) \to \text{List}(A)$

**Elimination principle**:
$$\text{listrec} : \Pi A:\mathcal{U}. \Pi C:\mathcal{U}. C \to (A \to \text{List}(A) \to C \to C) \to \text{List}(A) \to C$$

### [[Well-Founded Trees]] (W-types)
The general schema for [[inductive types]], $W_{x:A}B(x)$, represents trees where:
- Each node has label from type $A$
- A node with label $a:A$ has children indexed by $B(a)$

**Formation**: 
$$\frac{\Gamma \vdash A : \mathcal{U}_i \quad \Gamma, x:A \vdash B(x) : \mathcal{U}_j}{\Gamma \vdash W_{x:A}B(x) : \mathcal{U}_{\max(i,j)}}$$

**Introduction**: 
$$\frac{\Gamma \vdash a : A \quad \Gamma \vdash f : B(a) \to W_{x:A}B(x)}{\Gamma \vdash \text{sup}(a,f) : W_{x:A}B(x)}$$

## [[Meaning Explanations]]

MLTT employs [[meaning explanations]] rather than [[model-theoretic semantics]]. Types are explained through:

### [[Canonical Forms]]
- **Functions**: $\lambda x.b(x)$ where $b(x)$ computes to canonical form when $x$ is canonical
- **Pairs**: $(a,b)$ where $a$ and $b$ are canonical
- **Natural numbers**: $0, \text{succ}(0), \text{succ}(\text{succ}(0)), \ldots$
- **Equality proofs**: $\text{refl}_a$ when $a$ is canonical

### [[Equality Conditions]]
Two canonical elements of the same type are equal when:
- **Functions**: $\lambda x.b_1(x) = \lambda x.b_2(x)$ iff $b_1(c) = b_2(c)$ for all canonical $c$
- **Pairs**: $(a_1,b_1) = (a_2,b_2)$ iff $a_1 = a_2$ and $b_1 = b_2$
- **Reflexivity**: $\text{refl}_a = \text{refl}_b$ iff $a = b$

## [[Propositions as Types]] Implementation

MLTT realizes the [[Curry-Howard correspondence]] through:

### [[Logical Connectives]]
$$\begin{align}
\top &\leftrightarrow \mathbf{1} \text{ (unit type)} \\
\bot &\leftrightarrow \mathbf{0} \text{ (empty type)} \\
A \land B &\leftrightarrow A \times B \\
A \lor B &\leftrightarrow A + B \\
A \to B &\leftrightarrow A \to B \\
\forall x:A.B(x) &\leftrightarrow \Pi x:A.B(x) \\
\exists x:A.B(x) &\leftrightarrow \Sigma x:A.B(x)
\end{align}$$

### [[Proof Terms]]
Proofs correspond to terms of proposition types:
- **Modus ponens**: If $f : A \to B$ and $a : A$, then $f(a) : B$
- **Universal instantiation**: If $g : \Pi x:A.B(x)$ and $a : A$, then $g(a) : B(a)$
- **Existential introduction**: If $a : A$ and $b : B(a)$, then $(a,b) : \Sigma x:A.B(x)$

## [[Definitional vs Propositional Equality]]

MLTT distinguishes two levels of equality:

### [[Definitional Equality]] ($\equiv$)
[[Computational equality]] based on [[reduction rules]]:
$$(\lambda x.b)(a) \equiv b[a/x]$$
$$\text{fst}((a,b)) \equiv a$$

Definitional equality is:
- **Decidable** (in principle)
- **Substitutional**: if $a \equiv b$ then $C(a) \equiv C(b)$
- **Preserved by typing**: if $a \equiv b$ and $a : A$, then $b : A$

### [[Propositional Equality]] ($=$)
Equality as a type $\text{Id}_A(a,b)$ requiring proof:
- **Not necessarily decidable**
- **Can be reasoned about** using elimination principles
- **Subject to** [[proof relevance]]

The relationship: $a \equiv b \Rightarrow \text{Id}_A(a,b)$ (via reflexivity).

## [[Extensional vs Intensional]]

MLTT is fundamentally [[intensional]], meaning:

### [[Function Intensionality]]
Functions $f, g : \Pi x:A.B(x)$ can be [[pointwise equal]] without being [[propositionally equal]]:
$$\left(\Pi x:A. \text{Id}_{B(x)}(f(x),g(x))\right) \not\Rightarrow \text{Id}_{\Pi x:A.B(x)}(f,g)$$

### [[Proof Relevance]]
Multiple proofs of the same proposition are distinguished:
$$p, q : \text{Id}_A(a,b) \text{ need not satisfy } \text{Id}_{\text{Id}_A(a,b)}(p,q)$$

## [[Normalization]] and [[Decidability]]

MLTT enjoys crucial [[meta-theoretic properties]]:

### [[Strong Normalization]]
Every well-typed term has a [[normal form]] reached by finitely many reduction steps. This ensures:
- **Logical consistency**: No proof of $\mathbf{0}$
- **Decidable type checking**: Equality is decidable for normal forms

### [[Canonicity]]
Every closed term of natural number type reduces to a numeral:
$$\vdash t : \mathbb{N} \Rightarrow t \equiv \text{succ}^n(0) \text{ for some } n$$

This ensures [[computational content]] of proofs.

## [[Categorical Semantics]]

MLTT interprets in [[locally Cartesian closed categories]] (LCCCs) with additional structure:

### [[Context Categories]]
- **Objects**: Contexts $\Gamma = x_1:A_1, \ldots, x_n:A_n$
- **Morphisms**: Substitutions $\sigma : \Delta \to \Gamma$
- **Terminal object**: Empty context $\diamond$

### [[Dependent Type Interpretation]]
- **Types in context**: Functors $A : \mathcal{C}/\Gamma \to \mathcal{C}$
- **Terms**: Sections of type fibrations
- **Dependent functions**: Right adjoints to weakening functors

The [[syntax-semantics correspondence]] requires:
$$\llbracket \Gamma \vdash A : \text{Type} \rrbracket : \mathcal{C}/\llbracket \Gamma \rrbracket \to \mathcal{C}$$

## [[Homotopy Type Theory]] Connection

MLTT serves as the foundation for [[Homotopy Type Theory]] through reinterpretation:

### [[Homotopical Reading]]
- **Types** as [[topological spaces]] or [[∞-groupoids]]
- **Terms** as [[points]]
- **Identity types** as [[path spaces]]
- **Identity proofs** as [[continuous paths]]

### [[Higher Identity Types]]
Iterated identity types form [[higher homotopy groups]]:
$$\pi_n(A,a) := \text{Id}^n_A(a,a) = \underbrace{\text{Id}_{\text{Id}_{\cdots}}}_{n \text{ times}}(\text{refl}, \text{refl})$$

## Extensions and Variants

### [[Observational Type Theory]]
Adds [[function extensionality]] and [[proof irrelevance]] while maintaining decidability through [[observational equality]].

### [[Cubical Type Theory]]
Provides [[computational univalence]] through [[cubical sets]] and [[path types]] with [[composition operations]].

### [[Two-Level Type Theory]]
Distinguishes [[fibrant]] and [[non-fibrant]] types, enabling [[strict equality]] alongside [[homotopical equality]].

## Implementation in Proof Assistants

### [[Agda]]
Implements predicative MLTT with:
- **Universe polymorphism**: $\text{Set}_\ell$ parameterized by levels
- **Inductive families**: Generalized inductive types
- **Pattern matching**: Computational elimination principles

### [[Coq]]
Extends MLTT in the [[Calculus of Inductive Constructions]] with:
- **Impredicative Prop**: Propositions universe
- **Coinductive types**: For infinite structures  
- **Module system**: Large-scale organization

## [[Philosophy of Mathematics]] Implications

MLTT embodies several philosophical positions:

### [[Constructivism]]
Mathematical objects must be [[explicitly constructed]], rejecting [[non-constructive existence proofs]].

### [[Intuitionism]]
Meaning is determined by [[proof conditions]] rather than [[truth conditions]], leading to rejection of [[law of excluded middle]].

### [[Predicativism]]  
Definitions cannot quantify over collections containing the object being defined, motivating the [[universe hierarchy]].

## Related Concepts

- [[Constructive Logic]]
- [[Dependent Types]]
- [[Curry-Howard Correspondence]]
- [[Intensional Type Theory]]
- [[Homotopy Type Theory]]
- [[Proof Assistants]]
- [[Type-Theoretic Foundations]]
- [[Inductive Types]]
- [[Identity Types]]
- [[Meaning Explanations]]


---

preceding: [[intensional type theory]]  


following: [[predicative hierarchy]]

See also: [[type theory]]


See also: [[homotopy groups]]