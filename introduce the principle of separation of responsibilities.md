---
date: 1726441482.320242
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_c5bda929-608e-4c05-86e5-5a9554a1c08b
- msg_aaa2098e-0eaa-4cc2-8cb4-386b1ec8bf80
- msg_7f36de98-3217-4439-a652-905814e6470c
- colorclass/edge-case
title: introduce the principle of separation of responsibilities
---

**ASSISTANT**

only respond with questions or to act as a mentor, tutor, or collaborator in a specific field.

---

### **Summary**:

In this assignment, students learn to implement **per-agent personalities** by defining distinct system prompts for each agent. By giving agents unique roles and tones (researcher, creative writer, friendly chatbot), students can see how system prompts shape responses and create varied conversational experiences. The assignment reinforces concepts like system prompts, role-based conversation, and list management, all while building toward a flexible, multi-agent CLI chatbot.


**USER**

introduce the principle of separation of responsibilities


**ASSISTANT**

### **Assignment: Separation of Responsibilities in Code Design**

In this assignment, we will introduce students to the **principle of separation of responsibilities** (also known as **separation of concerns**). This principle emphasizes dividing a program into distinct sections, where each section is responsible for a specific aspect of functionality. By doing so, you make the code more modular, maintainable, and easier to debug or extend.

### **Objective**:
1. Teach students the importance of separating different responsibilities in their code.
2. Refactor the existing chatbot implementation to better separate the concerns of conversation management, agent behavior, and the interface.
3. Show how this principle makes the code easier to maintain, extend, and test.

---

### **What Is Separation of Responsibilities?**

**Separation of responsibilities** is the practice of organizing code so that different parts of a system are responsible for distinct tasks. Each part should have **one clear role**, making the program:
- **Modular**: You can easily change one part of the system without affecting others.
- **Maintainable**: Clear boundaries make the code easier to read and maintain.
- **Reusable**: By separating concerns, you can reuse components in different contexts.
- **Testable**: Itâ€™s easier to test isolated components individually.

---

### **Step 1: Identifying Responsibilities in the Chatbot**

Let's break down the chatbot into its core **responsibilities**:
1. **Agent Behavior**: Each agent has a personality, a system prompt, and manages conversation history. This part is responsible for how the agent behaves and interacts with the API.
2. **Conversation Management**: This part keeps track of the interaction between the user and the agent (e.g., storing and retrieving conversation history).
3. **User Interface**: This part handles how the user interacts with the system, such as taking user input and displaying responses from the agent.

Currently, all of these responsibilities are intertwined in the chatbot code. To follow the principle of separation of responsibilities, we need to refactor the code so each component handles a single responsibility.

---

### **Step 2: Refactoring the Chatbot for Separation of Responsibilities**

We will refactor the chatbot to have clear, separate components:
1. **Agent**: This class handles all the agent-specific behavior (system prompt, querying the API, maintaining history).
2. **Conversation Manager**: This class will manage the session by delegating tasks to agents and keeping track of user inputs and responses.
3. **Chatbot Interface**: This will handle user input and output, interacting with the conversation manager.

---

### **Step 3: Refactoring the `Agent` Class**

The **Agent** class is already well-structured, handling the specific responsibilities of the agent (e.g., system prompt and interaction with the API). We will leave this as-is, but clearly describe its role in managing agent-specific behavior.

```python
import openai
from jinja2 import Template

class Agent:
    def __init__(self, name, system_prompt_template):
        self.name = name
        self.system_prompt_template = system_prompt_template
        self.history = []  # Conversation history with system, user, and assistant roles
        # Add the system prompt as the first message
        self.history.append({"role": "system", "content": self.get_system_prompt()})
    
    def get_system_prompt(self):
        """
        Render the system prompt based on the agent's name and personality.
        """
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
    
    def query_openai(self, user_input, max_tokens=100, temperature=0.7, top_p=1.0, **kwargs):
        """
        Send the conversation history to OpenAI and maintain the chat log.
        """
        # Append the user's input to the history
        self.history.append({"role": "user", "content": user_input})
        
        # Send the conversation history (including system, user, and assistant roles) to the API
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",  # Using a chat model that supports roles
            messages=self.history,
            max_tokens=max_tokens,
            temperature=temperature,
            top_p=top_p,
            **kwargs
        )
        
        # Extract the assistant's reply and append it to the history
        assistant_reply = response.choices[0].message["content"]
        self.history.append({"role": "assistant", "content": assistant_reply})
        
        return assistant_reply
    
    def get_history(self):
        """
        Retrieve the conversation history for this agent.
        """
        return [entry for entry in self.history if entry["role"] != "system"]
```

---

### **Step 4: Creating a Conversation Manager**

The **Conversation Manager** class will be responsible for:
1. Handling multiple agents.
2. Managing which agent the user is interacting with.
3. Delegating queries to the correct agent.

```python
class ConversationManager:
    def __init__(self):
        # Initialize an empty dictionary to store agents by name
        self.agents = {}

    def add_agent(self, name, system_prompt_template):
        """
        Add a new agent to the conversation.
        """
        self.agents[name] = Agent(name, system_prompt_template)
    
    def get_agent(self, name):
        """
        Retrieve an agent by name.
        """
        return self.agents.get(name)

    def get_available_agents(self):
        """
        Return the names of available agents.
        """
        return list(self.agents.keys())
    
    def interact_with_agent(self, agent_name, user_input):
        """
        Send the user's input to the selected agent and return the agent's response.
        """
        agent = self.get_agent(agent_name)
        if not agent:
            return f"No agent found with the name {agent_name}."
        
        return agent.query_openai(user_input)
    
    def get_agent_history(self, agent_name):
        """
        Retrieve the conversation history for the selected agent.
        """
        agent = self.get_agent(agent_name)
        if agent:
            return agent.get_history()
        return []
```

---

### **Step 5: Refactoring the Chatbot Interface**

The **Chatbot Interface** will now be responsible for:
- Handling user input.
- Displaying available agents.
- Interacting with the **Conversation Manager** to route user inputs to the appropriate agent.

```python
def chatbot_interface():
    # Create the conversation manager
    conversation_manager = ConversationManager()

    # Define the system prompts for the agents
    alice_system_prompt = "You are {{ name }}, a research assistant. Provide detailed, factual answers with references where possible."
    bob_system_prompt = "You are {{ name }}, a creative writing assistant. Respond with playful, imaginative, and creative writing."
    charlie_system_prompt = "You are {{ name }}, a friendly chatbot. Respond in a casual and approachable tone, as if having a light-hearted conversation with a friend."

    # Add agents to the conversation
    conversation_manager.add_agent("Alice", alice_system_prompt)
    conversation_manager.add_agent("Bob", bob_system_prompt)
    conversation_manager.add_agent("Charlie", charlie_system_prompt)

    # Start the user interface loop
    print("Welcome to the multi-agent chatbot!\n")
    while True:
        print("Available agents:")
        for agent_name in conversation_manager.get_available_agents():
            print(f"- {agent_name}")
        
        chosen_agent = input("Enter the agent's name (or type 'exit' to quit): ").strip()
        if chosen_agent.lower() == "exit":
            break
        
        if chosen_agent not in conversation_manager.get_available_agents():
            print("Invalid agent name. Please try again.\n")
            continue
        
        while True:
            user_input = input(f"You (talking to {chosen_agent}): ")
            if user_input.lower() == "exit":
                break
            
            # Send the user input to the selected agent
            response = conversation_manager.interact_with_agent(chosen_agent, user_input)
            print(f"{chosen_agent}: {response}")
        
        # After exiting the conversation, print the agent's conversation history
        print(f"\n{chosen_agent}'s conversation history:")
        for entry in conversation_manager.get_agent_history(chosen_agent):
            print(f"{entry['role'].capitalize()}: {entry['content']}")
        print()

# Run the chatbot interface
if __name__ == "__main__":
    chatbot_interface()
```

---

### **Step 6: Running the Refactored Chatbot**

When you run the refactored chatbot, the responsibilities are clearly separated into:
1. **Agent**: Handles personality, system prompts, and interaction with OpenAI.
2. **Conversation Manager**: Manages agents, interaction routing, and conversation history.
3. **Chatbot Interface**: Handles user input and displays output.

```bash
Welcome to the multi-agent chatbot!

Available agents:
- Alice
- Bob
- Charlie
Enter the agent's name (or type 'exit' to quit): Alice
You (talking to Alice): Can you explain quantum mechanics?
Alice: Quantum mechanics is a fundamental theory in physics that describes the physical properties of nature at the scale of atoms and subatomic particles...

Alice's conversation history:
User: Can you explain quantum mechanics?
Assistant: Quantum mechanics is a fundamental theory in physics that describes the physical properties of nature at the scale of atoms and subatomic particles...
```

---

### **Learning Outcomes**:

1. **Separation of Responsibilities**: 
   - Students will understand how to separate different parts of the program into clear, distinct components (Agent, Conversation Manager, and User Interface).
   
2. **Modularity and Maintainability**: 
   - By separating responsibilities, the code becomes more modular, easier to maintain, and easier to extend.
   
3. **Refactoring for Clarity**


---

preceding: [[assignment per-agent personalities]]  


following: [[next, discuss inter-agent collaboration. introduce the fact-checker agentic programming pattern and demonstrate it.]]

See also: [[separation of concerns]]