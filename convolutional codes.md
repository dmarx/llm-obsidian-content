---
date: 1719342513.350581
tags:
- autogenerated
- source__oai
- conversation_id__b7c336c1-f2dc-4e0a-b2e0-bbe32516848b
- msg_aaa26d10-aa19-486f-a81c-f0f7f23ee7f1
- msg_b0b214bd-62b3-4df9-9d16-be703a0554cb
- colorclass/vector-space
title: convolutional codes
---

**USER**

Convolutional Codes


**ASSISTANT**

### Convolutional Codes

Convolutional codes are a class of error-correcting codes used extensively in digital communications to improve the reliability of data transmission over noisy channels. Unlike block codes, which encode data in fixed-size blocks, convolutional codes process data as a continuous stream of bits, applying a sliding window to produce encoded output.

#### Key Concepts

1. **Encoder Structure**
   - A convolutional encoder consists of \(k\) input bits and \(n\) output bits, typically described as a \((n, k, m)\) code, where \(m\) is the memory of the encoder. The memory \(m\) represents the number of previous input bits the encoder uses to generate the current output bits.
   - The encoder can be represented by a finite-state machine, shift registers, or a trellis diagram.

2. **Generator Polynomials**
   - The encoding process is defined by generator polynomials. For a \((2, 1, m)\) encoder, there are typically two generator polynomials \(g_1(D)\) and \(g_2(D)\), where \(D\) denotes the delay operator.
   - Example: For a rate \(1/2\) code with memory 2, the generator polynomials might be \(g_1(D) = 1 + D + D^2\) and \(g_2(D) = 1 + D^2\).

3. **Encoding Process**
   - Given an input bit stream \(\mathbf{u} = (u_0, u_1, u_2, \ldots)\), the encoder produces an output bit stream \(\mathbf{v} = (v_0, v_1, v_2, \ldots)\) where each output \(v_i\) depends on the current and past input bits up to \(m\) previous bits.
   - The relationship can be written as:
     $$ v_i = (u_i \ast g_1(D), u_i \ast g_2(D)), $$
     where \(\ast\) denotes convolution.

4. **Trellis Diagram**
   - The trellis diagram is a graphical representation of the convolutional code, illustrating how the input bits and the encoder's state evolve over time. Each state in the trellis corresponds to a unique combination of the encoder's memory bits.
   - The trellis is used for decoding and helps visualize the paths that represent valid code sequences.

#### Decoding Algorithms

1. **Viterbi Algorithm**
   - The Viterbi algorithm is the most commonly used algorithm for decoding convolutional codes. It is an efficient maximum likelihood decoding algorithm that finds the most likely path through the trellis diagram.
   - The algorithm performs a dynamic programming approach to trace back the path with the highest probability of being the transmitted sequence.

2. **Sequential Decoding**
   - Sequential decoding is another method for decoding convolutional codes, typically used for codes with large constraint lengths where the Viterbi algorithm may be computationally impractical.
   - Examples include the Fano algorithm, which uses a tree search to find the most likely path but with less computational complexity compared to the Viterbi algorithm.

3. **BCJR Algorithm**
   - The BCJR (Bahl, Cocke, Jelinek, and Raviv) algorithm is used for soft-decision decoding of convolutional codes, providing the a posteriori probabilities of each bit being a 0 or 1.

#### Performance Metrics

1. **Free Distance**
   - The free distance \(d_f\) of a convolutional code is the minimum Hamming distance between any two distinct code sequences. It determines the error-correcting capability of the code.

2. **Coding Gain**
   - Coding gain measures the improvement in signal-to-noise ratio (SNR) required to achieve the same error rate with and without the code. Convolutional codes typically offer significant coding gains.

3. **Bit Error Rate (BER)**
   - BER is the ratio of the number of bit errors to the total number of transmitted bits. It is a common measure of the performance of a coding scheme.

#### Examples

1. **Rate 1/2 Convolutional Code**
   - Consider a \((2, 1, 2)\) convolutional encoder with generator polynomials \(g_1(D) = 1 + D + D^2\) and \(g_2(D) = 1 + D^2\). For an input sequence \(\mathbf{u} = (1, 0, 1, 1)\), the output sequence \(\mathbf{v}\) can be computed as:
     - \(v_0 = (1, 1)\)
     - \(v_1 = (0, 1)\)
     - \(v_2 = (1, 0)\)
     - \(v_3 = (0, 1)\)

2. **Trellis Representation**
   - The states of the encoder can be represented as \((S_{t-2}, S_{t-1})\), where \(S_t\) is the state at time \(t\). The trellis diagram shows transitions between states based on input bits, with edges labeled by the corresponding output bits.

#### Applications

1. **Digital Communications**
   - Convolutional codes are widely used in various digital communication systems, including satellite communications, mobile networks, and deep-space communications.

2. **Error Correction in Storage**
   - Convolutional codes are also used in data storage devices to detect and correct errors during data retrieval.

3. **Voice and Video Transmission**
   - They are employed in voice and video transmission systems, such as GSM and CDMA mobile networks, to ensure reliable delivery of multimedia content.

In summary, convolutional codes are powerful error-correcting codes that provide robust performance in noisy communication environments. Their continuous encoding and efficient decoding algorithms, such as the Viterbi algorithm, make them suitable for a wide range of applications in digital communications and data storage.


---

preceding: [[singleton bound]]  


following: [[free distance]]

See also: [[coding gain]]


See also: [[dynamic programming]]