---
date: '2025-05-25T17:39:16.955048Z'
tags:
- autogenerated
- source__claude
- conversation_id__5f561911-5fb4-4b8e-a51e-2582fe6e5df5
- msg_527a1fbb-6349-49df-a2db-cbe18dbcb1fb
- msg_bc491a16-c3d2-4f9f-8906-534b00ea86b9
- colorclass/information-theory
title: capability calculus
---

**USER**

capability calculus


**ASSISTANT**

# Capability Calculus

## Definition and Theoretical Foundation

A [[Capability Calculus]] is a formal mathematical framework for reasoning about [[object-capability systems]], providing precise notation and rules for expressing capability creation, transfer, invocation, and composition. It extends traditional [[process calculi]] with explicit representation of authority and reference relationships.

## Mathematical Structure

### Basic Elements
**Capability**: $c = \langle r, P \rangle$ where:
- $r$ is an unforgeable reference to an object
- $P \subseteq \text{Operations}$ is the set of permitted operations

**Object**: $o = \langle \text{state}, \text{behavior} \rangle$ with:
- $\text{state} \in \mathcal{S}$ (object's internal state)
- $\text{behavior}: \text{Messages} \times \mathcal{S} \rightarrow \mathcal{S} \times \text{Responses}$

**Actor/Process**: $A = \langle \text{code}, \text{capabilities}, \text{queue} \rangle$

### Syntax
**Terms**:
$$t ::= \text{nil} \mid x \mid \langle t_1, \ldots, t_n \rangle \mid \text{new}(C) \mid t.m(\overline{t})$$

**Processes**:
$$P ::= 0 \mid \text{send}(t, m, \overline{t}) \mid \text{receive}(x, m, \overline{x}).P \mid P_1 \mid P_2 \mid \nu c.P \mid \text{if } \phi \text{ then } P$$

**Capabilities**:
$$\text{cap} ::= \text{read}(r) \mid \text{write}(r) \mid \text{invoke}(r, m) \mid \text{attenuate}(\text{cap}, \text{restrictions})$$

## Operational Semantics

### Capability Creation
**Object Creation Rule**:
$$\frac{\text{fresh}(r)}{\nu c.\langle \text{new}(C), \text{caps} \rangle \rightarrow \langle r, \text{caps} \cup \{c\} \rangle}$$

Where $c = \langle r, \text{full\_permissions} \rangle$ and $r$ refers to newly created object.

### Message Passing
**Send Rule**:
$$\frac{c = \langle r, P \rangle \in \text{caps} \land m \in P}{\langle \text{send}(c, m, \overline{v}), \text{caps} \rangle \rightarrow \langle \text{nil}, \text{caps} \rangle}$$

**Receive Rule**:
$$\frac{\text{message}(r, m, \overline{v}) \in \text{queue}}{\langle \text{receive}(x, m, \overline{y}).P, \text{caps} \rangle \rightarrow P[r/x, \overline{v}/\overline{y}]}$$

### Capability Transfer
**Reference Passing**:
$$\frac{c \in \text{caps}\_A}{\text{send}(B, \text{grant}, c) : \text{caps}\_A \rightarrow \text{caps}\_A, \text{caps}\_B \rightarrow \text{caps}\_B \cup \{c\}}$$

**Delegation Chain**: 
$$\text{delegate}(A, B, c) \Rightarrow \text{CanUse}(B, c) \land \text{Source}(c) = A$$

## Type System

### Capability Types
**Basic Types**:
$$\tau ::= \text{Int} \mid \text{Bool} \mid \text{Cap}[\tau, \text{perms}] \mid \tau_1 \rightarrow \tau_2 \mid \text{Object}[\text{interface}]$$

**Capability Type**: $\text{Cap}[\tau, P]$ represents capability to object of type $\tau$ with permissions $P$

**Subtyping Rule**:
$$\frac{P_1 \subseteq P_2}{\text{Cap}[\tau, P_1] <: \text{Cap}[\tau, P_2]}$$

### Linear Types
**Affine Capabilities**: Each capability used at most once
$$\frac{\Gamma, x: \text{Cap}[\tau, P] \vdash e: \sigma \land \text{Linear}(x)}{\Gamma \vdash \lambda x.e: \text{Cap}[\tau, P] \multimap \sigma}$$

**Resource Management**: Prevent capability duplication
$$\frac{\Gamma \vdash c: \text{Cap}[\tau, P]}{\Gamma \setminus \{c\} \vdash \text{use}(c): \tau}$$

## Security Properties

### Confinement
**Formal Definition**: Process $P$ is confined if:
$$\forall c \notin \text{InitialCaps}(P): \neg\text{CanAccess}(P, c)$$

**Confinement Theorem**:
$$\text{NoInitialCaps}(P) \land \text{NoCapabilityCreation}(P) \Rightarrow \text{TotalConfinement}(P)$$

### Authority Ordering
**Capability Lattice**: $(C, \preceq)$ where $c_1 \preceq c_2$ iff $c_1$ can be derived from $c_2$

**Attenuation Property**:
$$\text{attenuate}(c, R) \preceq c$$

**Monotonicity**: 
$$c_1 \preceq c_2 \land c_2 \preceq c_3 \Rightarrow c_1 \preceq c_3$$

### Non-Interference
**Information Flow Security**:
$$\forall h \in \text{High}, l \in \text{Low}: \text{Obs}_l(\text{Exec}(P, h)) = \text{Obs}_l(\text{Exec}(P, \emptyset))$$

**Capability-Based Non-Interference**:
$$\text{Disjoint}(\text{Caps}_1, \text{Caps}_2) \Rightarrow \text{NoInterference}(P_1, P_2)$$

## Advanced Constructs

### Membrane Patterns
**Membrane Wrapper**:
$$\text{membrane}(c, \text{policy}) = \langle \text{proxy}, \text{intercept} \rangle$$

**Interception Function**:
$$\text{intercept}(m, \overline{args}) = \begin{cases}
\text{forward}(c, m, \overline{args}) & \text{if } \text{policy}(m, \overline{args}) \\
\text{deny}() & \text{otherwise}
\end{cases}$$

**Revocation Membrane**:
$$\text{revoke}(\text{membrane}(c, \text{policy})) \Rightarrow \text{policy} := \lambda m, \overline{args}.\text{false}$$

### Capability Composition
**Conjunction**: $c_1 \land c_2$ requires both capabilities
$$\frac{c_1 \in \text{caps} \land c_2 \in \text{caps}}{\text{use}(c_1 \land c_2)}$$

**Disjunction**: $c_1 \lor c_2$ accepts either capability
$$\frac{c_1 \in \text{caps} \lor c_2 \in \text{caps}}{\text{use}(c_1 \lor c_2)}$$

**Temporal Capabilities**: $c \triangleright t$ (capability valid for time $t$)
$$\frac{c \in \text{caps} \land \text{current\_time} \leq t}{\text{use}(c \triangleright t)}$$

## Process Algebra Extensions

### Ï€-Calculus with Capabilities
**Enhanced Syntax**:
$$P ::= 0 \mid \text{out}(c, \overline{v}).P \mid \text{in}(c, \overline{x}).P \mid P_1 \mid P_2 \mid \nu c.P \mid !P$$

**Capability Channel Types**:
$$\text{Channel}[\text{Cap}[\tau, P]]$$

**Communication Rule**:
$$\frac{\text{type}(c) = \text{Channel}[\text{Cap}[\tau, P]]}{\text{out}(c, \text{cap}).P_1 \mid \text{in}(c, x).P_2 \rightarrow P_1 \mid P_2[\text{cap}/x]}$$

### Actor Model Integration
**Actor Creation**:
$$\text{spawn}(\text{behavior}, \text{initial\_caps}) \rightarrow \text{ActorRef}[\text{MessageType}]$$

**Message Send with Capability**:
$$\text{send}(\text{actor\_ref}, \text{message}, \text{capability})$$

**Behavior Function**:
$$\text{behavior}: (\text{Message}, \text{Capabilities}) \rightarrow (\text{Actions}, \text{NewCapabilities})$$

## Distributed Extensions

### Network Capabilities
**Network Reference**: $\text{netref} = \langle \text{address}, \text{crypto\_key}, \text{object\_id} \rangle$

**Distributed Capability**:
$$\text{distcap} = \langle \text{netref}, \text{permissions}, \text{constraints} \rangle$$

**Remote Invocation**:
$$\frac{\text{verify}(\text{crypto\_key}) \land \text{authorize}(\text{permissions}, m)}{\text{remote\_call}(\text{netref}, m, \overline{args})}$$

### Consensus and Capabilities
**Byzantine Capability Transfer**:
$$\text{consensus\_transfer}(c, A, B) \text{ requires } > \frac{2n}{3} \text{ honest nodes}$$

**Capability Voting**:
$$\text{grant}(c) \Leftrightarrow \sum_{i} \text{vote}_i(\text{grant}, c) > \text{threshold}$$

## Temporal Logic Specifications

### Linear Temporal Logic (LTL)
**Capability Safety**:
$$\square(\text{use}(c) \rightarrow \text{holds}(c))$$

**Eventual Capability Transfer**:
$$\square(\text{request}(c) \rightarrow \diamond \text{grant}(c))$$

**Capability Liveness**:
$$\square \diamond \text{capability\_available}$$

### Computation Tree Logic (CTL)
**Capability Reachability**:
$$\text{EF}(\text{can\_access}(o))$$

**Universal Capability Safety**:
$$\text{AG}(\text{access}(o) \rightarrow \text{authorized}(o))$$

## Mechanized Verification

### Coq Formalization
```coq
Inductive capability : Type :=
  | Cap : object_ref -> permissions -> capability.

Definition capability_transfer (c : capability) (from to : actor) : Prop :=
  holds from c /\ ~holds to c -> 
  ~holds from c /\ holds to c.

Theorem capability_conservation :
  forall c from to,
  capability_transfer c from to ->
  holds from c \/ holds to c.
```

### TLA+ Specification
```tla+
VARIABLES capabilities, actors, objects

CapabilityInvariant ==
  \A c \in capabilities :
    \E a \in actors : Holds(a, c)

TransferAction(c, from, to) ==
  /\ Holds(from, c)
  /\ ~Holds(to, c)
  /\ capabilities' = capabilities
  /\ Holds(from, c)' = FALSE
  /\ Holds(to, c)' = TRUE
```

## Complexity Analysis

### Capability Resolution
**Lookup Complexity**: $O(\log |\text{capabilities}|)$ using hash tables

**Path Resolution**: $O(d)$ where $d$ is delegation chain depth

**Distributed Resolution**: $O(\log n)$ hops in distributed hash table

### Type Checking
**Capability Type Inference**: 
$$\text{PTIME} \text{ for simply-typed capability calculus}$$
$$\text{EXPTIME} \text{ with dependent types and linear capabilities}$$

### Reachability Analysis
**Capability Reachability**: Given capabilities $C$ and target $o$, can any $c \in C$ reach $o$?

**Complexity**: $\text{PSPACE-complete}$ for general capability graphs

## Game-Theoretic Analysis

### Capability Trading
**Market Mechanism**: Capabilities as tradeable commodities

**Price Function**: $p(c) = f(\text{rarity}(c), \text{utility}(c), \text{risk}(c))$

**Nash Equilibrium**: 
$$\forall i: \text{utility}_i(\text{strategy}_i^*, \text{strategy}_{-i}^*) \geq \text{utility}_i(\text{strategy}_i, \text{strategy}_{-i}^*)$$

### Auction Mechanisms
**Capability Auction**:
$$\max_{\text{allocation}} \sum_i v_i(\text{allocated\_caps}_i) - t_i$$

**VCG Payment**:
$$t_i = \sum_{j \neq i} v_j(\text{allocation}_{-i}) - \sum_{j \neq i} v_j(\text{allocation})$$

## Information-Theoretic Properties

### Capability Entropy
**Information Content**: $H(C) = -\sum_c P(c) \log P(c)$

**Conditional Entropy**: $H(C|A)$ = entropy of capabilities given actor identity

**Mutual Information**: $I(A; C) = H(C) - H(C|A)$

### Capability Compression
**Kolmogorov Complexity**: $K(C)$ = minimum description length of capability set

**Capability Sharing**: $K(C_1 \cup C_2) \leq K(C_1) + K(C_2)$ with equality for independent sets

## Quantum Extensions

### Quantum Capabilities
**Quantum State Capability**: $|c\rangle = \alpha|0\rangle + \beta|1\rangle$

**No-Cloning Property**: Quantum capabilities cannot be duplicated
$$\nexists U: U|c\rangle|0\rangle = |c\rangle|c\rangle$$

**Quantum Entanglement**: Shared capabilities through entangled states
$$|\text{shared\_cap}\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$$

### Quantum Protocols
**Quantum Key Distribution**: Capability transfer using quantum channels

**Verification Protocol**: Prove capability possession without revealing it
$$\text{QZK-Proof}(\text{HasCap}(c)) \land \neg\text{Reveals}(c)$$

## Applications

### Operating Systems
**seL4**: Microkernel with formal capability model
- CNode: Capability namespace
- Endpoint: Communication capability
- Frame: Memory capability

**Mathematical Model**:
$$\text{KernelCall}(c, \text{args}) \Rightarrow \text{Authorized}(c, \text{operation}) \land \text{Valid}(\text{args})$$

### Programming Languages
**E Language**: Pure object-capability language
```e
def makeMint(name) {
    def [purse, decr] := Purse.makeAtPair()
    def mint := [
        def makePurse(amount) { purse<-deposit(amount); purse }
        def destroy(p) { decr<-destroy(p) }
    ]
    return mint
}
```

### Distributed Systems
**Waterken Server**: HTTP-based capability system
- URLs as unguessable capabilities
- Cryptographic integrity protection
- RESTful capability invocation

**Capability URL**: `https://example.com/cap/a8f7b2c4d1e9?key=sha256hash`

## Research Frontiers

### Machine Learning Integration
**Capability-Based ML**: Training models with explicit data access capabilities

**Privacy-Preserving Inference**: Capabilities for accessing specific features without full dataset access

### Blockchain Applications
**Smart Contract Capabilities**: On-chain capability management
```solidity
mapping(address => mapping(bytes32 => bool)) capabilities;

function invoke(bytes32 capId, bytes data) external {
    require(capabilities[msg.sender][capId], "Unauthorized");
    // Execute capability-protected operation
}
```

### Neuromorphic Computing
**Capability Neurons**: Neural networks where connections represent capabilities

**Learning Dynamics**: Capability strengthening/weakening based on usage patterns

**Spike-Based Authority**: Event-driven capability exercising in spiking neural networks

### Post-Quantum Cryptography
**Lattice-Based Capabilities**: Capabilities secured against quantum attacks

**Code-Based Capability Transfer**: Using error-correcting codes for capability protocols

### Formal Methods Integration
**Model Checking**: Verify temporal properties of capability systems

**Theorem Proving**: Machine-checked proofs of capability safety properties

**Refinement**: Formal relationship between specification and implementation


---

preceding: [[ambient authority]]  


following: [[process calculus]]