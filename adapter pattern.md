---
date: 1727917007.914949
tags:
- autogenerated
- source__oai
- conversation_id__66fdeb95-c32c-8008-9a23-d10da96b1985
- msg_d48f1632-c8f3-42ec-8599-c38ece808b32
- msg_066e04ec-b16a-404e-8acf-71fdd3e7a579
- colorclass/edge-case
title: adapter pattern
---

**USER**

adapter pattern


**ASSISTANT**

The **Adapter Pattern** is a structural design pattern in software engineering that allows incompatible interfaces of different classes to work together. By wrapping an existing class with an adapter, this pattern provides a unified interface to clients, decoupling the system components and promoting reuse.

## Intent of the Adapter Pattern

The main goal of the adapter pattern is to:

- **Translate Interfaces:** Convert the interface of a class into another interface that a client expects, allowing two incompatible systems to work together.
- **Achieve Reusability:** Enable the reuse of existing code without modification by adapting its interface.
- **Facilitate Code Integration:** Integrate third-party libraries or legacy systems into a new system with minimal changes.

The adapter pattern is particularly useful in situations where a class that needs to be used by a client code has an incompatible interface, and direct modification of either the class or the client is not feasible.

## Structure of the Adapter Pattern

The adapter pattern involves three main components:

1. **Client:** The entity that requires a specific interface to perform an action.
2. **Target Interface:** The interface that the client expects.
3. **Adaptee:** The existing class that needs to be adapted to the target interface.
4. **Adapter:** A class that implements the target interface and wraps an instance of the adaptee, translating the client's requests to the format expected by the adaptee.

### Example: Adapting a Legacy Interface in Python

Imagine you have a legacy class that provides temperature readings in Celsius, but the client expects temperatures in Fahrenheit:

#### Adaptee (Legacy Temperature Sensor)
```python
class CelsiusTemperatureSensor:
    def get_temperature_celsius(self):
        return 25  # Returns temperature in Celsius
```

#### Target Interface
```python
class TemperatureSensor:
    def get_temperature_fahrenheit(self):
        pass  # Expected method for temperature readings in Fahrenheit
```

#### Adapter
```python
class CelsiusToFahrenheitAdapter(TemperatureSensor):
    def __init__(self, celsius_sensor):
        self.celsius_sensor = celsius_sensor
    
    def get_temperature_fahrenheit(self):
        celsius = self.celsius_sensor.get_temperature_celsius()
        # Convert Celsius to Fahrenheit
        return (celsius * 9 / 5) + 32
```

#### Client Code
```python
celsius_sensor = CelsiusTemperatureSensor()
adapter = CelsiusToFahrenheitAdapter(celsius_sensor)

print(f"Temperature in Fahrenheit: {adapter.get_temperature_fahrenheit()}")
```

Here:
- **Client:** The client expects a `TemperatureSensor` interface.
- **Target Interface:** `TemperatureSensor` provides a `get_temperature_fahrenheit()` method.
- **Adaptee:** `CelsiusTemperatureSensor` has a method to provide temperature in Celsius.
- **Adapter:** `CelsiusToFahrenheitAdapter` adapts the `CelsiusTemperatureSensor` to conform to the `TemperatureSensor` interface by implementing the required method and internally converting the temperature.

## Types of Adapter Patterns

- **Class Adapter:** Uses inheritance to adapt an interface. This is common in languages that support multiple inheritance (like C++).
- **Object Adapter:** Uses composition, where the adapter contains an instance of the adaptee. This is more flexible and commonly used in languages that do not support multiple inheritance, such as Java and Python.

## When to Use the Adapter Pattern

- When you have an existing class whose interface does not match the one you need.
- When you want to use a legacy class or a third-party library with a different interface than expected.
- When you need to create reusable code by decoupling the client from the specific implementations of an interface.

## Related Patterns

- **[[Facade Pattern|Facade]]:** Similar in providing a unified interface, but differs in that it provides a simplified interface to a complex subsystem rather than adapting one to another.
- **[[Decorator Pattern|Decorator]]:** Wraps objects to add behavior, while adapters change the interface of the object.
- **[[Shim (Software Engineering)|Shim]]:** A shim acts as an intermediary for compatibility, somewhat analogous to an adapter but usually for adapting low-level software components like APIs or operating systems.

By implementing the adapter pattern, software components become more flexible and easier to integrate, improving the overall maintainability and extensibility of the system.


---

preceding: [[shim (software engineering)]]  


following: [[dependency injection]]