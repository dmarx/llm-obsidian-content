---
date: '2025-05-25T17:11:09.861786Z'
tags:
- autogenerated
- source__claude
- conversation_id__5f561911-5fb4-4b8e-a51e-2582fe6e5df5
- msg_41481308-1a0a-441f-a2bf-989f0c9bdaf4
- msg_703c43b6-7355-48ed-8bc7-dbfcffa7e830
- colorclass/game-theory
title: object-capability principle
---

**USER**

object-capability principle


**ASSISTANT**

# Object-Capability Principle

## Definition and Theoretical Foundation

The [[object-capability principle]] establishes that **authority and designation should be unified** - the ability to name or reference an object should inherently carry the authority to interact with that object. This principle eliminates the distinction between [[possession]] and [[permission]], creating a security model where **capability equals authority**.

## Mathematical Formalization

Let $\mathcal{O}$ be the set of objects, $\mathcal{S}$ be the set of subjects (actors), and $\mathcal{R}$ be the set of references. The object-capability principle can be formalized as:

$$\forall s \in \mathcal{S}, o \in \mathcal{O}: \text{CanReference}(s, o) \iff \text{CanInvoke}(s, o)$$

More precisely, if $\mathcal{C}: \mathcal{S} \times \mathcal{O} \rightarrow \mathcal{P}(\text{Operations})$ represents the capability function mapping subject-object pairs to sets of permitted operations:

$$\mathcal{C}(s, o) = \begin{cases}
\text{Operations}(o) & \text{if } o \in \text{Reachable}(s) \\
\emptyset & \text{otherwise}
\end{cases}$$

Where $\text{Reachable}(s)$ denotes the [[transitive closure]] of objects accessible from subject $s$ through existing references.

## Core Principles

### Designation and Authority Unity
**Formal Property**: $\text{Reference} \equiv \text{Capability}$

Traditional access control systems maintain separate mappings:
- **Designation**: $D: \text{Names} \rightarrow \text{Objects}$  
- **Authorization**: $A: \text{Subjects} \times \text{Objects} \rightarrow \text{Permissions}$

Object-capabilities collapse this into a single relation:
- **Capability**: $C: \text{References} \rightarrow \text{Objects} \times \text{Permissions}$

### No Ambient Authority
**Mathematical Constraint**: $\nexists o \in \mathcal{O}: \forall s \in \mathcal{S}, s \text{ can access } o$

No object is globally accessible without explicit capability transfer. This eliminates [[ambient authority]] - the ability to access resources based solely on identity or context.

**Information-Theoretic Interpretation**: The [[mutual information]] between subject identity and accessible objects should be minimal:
$$I(\text{Subject Identity}; \text{Accessible Objects}) \approx 0$$

### Capability Propagation
Capabilities can be transferred between subjects through explicit mechanisms:

$$\text{Transfer}: \mathcal{S} \times \mathcal{S} \times \text{Capability} \rightarrow \text{Bool}$$

Subject $s_1$ can grant capability $c$ to subject $s_2$ if and only if $s_1$ possesses $c$ and chooses to transfer it.

## Category-Theoretic Perspective

### Objects as Functors
In the object-capability model, objects can be viewed as [[functors]] from the category of messages to the category of effects:

$$\text{Object}: \mathcal{M}\text{essages} \rightarrow \mathcal{E}\text{ffects}$$

A capability is then a [[natural transformation]] that preserves the compositional structure of message passing.

### Capability Composition
Capabilities form a [[preordered set]] under the relation "can be derived from":

$$c_1 \preceq c_2 \iff c_1 \text{ can be obtained from } c_2$$

This creates a [[lattice structure]] where:
- **Join** ($\vee$): Union of capabilities
- **Meet** ($\wedge$): Intersection of capabilities  
- **Top** ($\top$): Universal capability (typically nonexistent)
- **Bottom** ($\bot$): Null capability

## Security Properties

### Principle of Least Authority (POLA)
**Formal Statement**: Each component should receive the minimal set of capabilities necessary for its intended function.

$$\forall \text{component } c: \text{Capabilities}(c) = \min\{S \subseteq \mathcal{C} : \text{CanFunction}(c, S)\}$$

### Capability Confinement
The [[confinement property]] ensures that capabilities cannot be [[exfiltrated]] beyond their intended scope:

$$\text{Confined}(c) \iff \forall t > 0: \text{Reachable}(c, t) \subseteq \text{Reachable}(c, 0)$$

### Fail-Safe Defaults
In capability systems, **lack of capability equals lack of access**:

$$\neg\text{HasCapability}(s, o) \implies \neg\text{CanAccess}(s, o)$$

This creates [[fail-safe]] rather than [[fail-open]] behavior.

## Implementation Models

### Pure Object-Capability Languages
**Example**: [[E Language]], where all object references are unforgeable capabilities.

**Invariant**: $\forall \text{reference } r: \text{Unforgeable}(r) \land \text{Unguessable}(r)$

References are:
- **Unforgeable**: Cannot be created without proper authority
- **Unguessable**: Cannot be determined through brute force or inference

### Membrane Patterns
**Definition**: A [[membrane]] is a [[capability wrapper]] that intercepts and potentially modifies all interactions with an object.

$$\text{Membrane}(o) = \{m : \forall \text{msg}, m(\text{msg}, o) \text{ controls access to } o\}$$

Membranes enable:
- **[[Capability Attenuation]]**: Reducing the power of capabilities
- **[[Audit Trails]]**: Logging all capability exercises  
- **[[Revocation]]**: Dynamically removing capabilities

### Proxy-Based Capabilities
**JavaScript Example**: Using [[Proxy objects]] to implement capability boundaries:

```javascript
const capability = new Proxy(object, {
  get(target, property) {
    if (hasPermission(property)) {
      return target[property];
    }
    throw new Error('Access denied');
  }
});
```

## Distributed Systems Applications

### Network Protocols
In distributed object-capability systems, references become [[network capabilities]]:

$$\text{NetworkRef} = (\text{Address}, \text{CryptoKey}, \text{ObjectID})$$

Where:
- **Address**: Network location
- **CryptoKey**: Cryptographic proof of authority
- **ObjectID**: Specific object identifier

### [[Blockchain]] and [[Smart Contracts]]
Cryptocurrency addresses function as capabilities - possession of the private key grants authority over the associated funds:

$$\text{UTXOSpendable}(u) \iff \text{HasPrivateKey}(\text{Address}(u))$$

### [[Actor Model]] Integration
In actor-based systems, actor references serve as capabilities:

$$\text{Send}(a_1, \text{msg}, a_2) \text{ possible} \iff a_1 \text{ has reference to } a_2$$

## Comparison with Traditional Access Control

### Access Control Lists (ACLs)
Traditional ACL systems separate identity and authority:

$$\text{ACL}: \text{Objects} \rightarrow \mathcal{P}(\text{Subjects} \times \text{Permissions})$$

**Problems**:
- **[[Confused Deputy]]**: Programs can be tricked into misusing their authority
- **[[Ambient Authority]]**: Global permissions based on identity
- **[[Temporal Coupling]]**: Authorization decisions separated from resource usage

### Capability-Based Alternative
$$\text{Capability}: \text{References} \rightarrow \text{Objects} \times \text{Permissions}$$

**Advantages**:
- **No Confused Deputy**: Capabilities carry explicit authority
- **[[Compositionality]]**: Capabilities combine naturally
- **[[Delegation]]**: Authority transfer is explicit and controlled

## Implementation Challenges

### Language-Level Support
Most mainstream languages violate object-capability principles through:

**Global Namespaces**:
$$\exists \text{global}: \forall s \in \mathcal{S}, s \text{ can access global}$$

**Ambient I/O Authority**:
$$\text{File.open}(\text{path}) \text{ succeeds based on OS permissions, not capabilities}$$

### Capability Patterns in Non-Capability Languages

#### Dependency Injection
**Pattern**: Pass capabilities as constructor parameters rather than accessing globals.

```python
class Service:
    def __init__(self, database_capability, logger_capability):
        self._db = database_capability
        self._logger = logger_capability
```

#### [[Context Managers]]
**Pattern**: Encapsulate capabilities within controlled scopes.

```python
with database_connection() as db_capability:
    # db_capability only available within this scope
    process_data(db_capability)
```

#### [[Capability Security]] Libraries
**Example**: [[OCAP]] (Object Capability) libraries that provide capability-safe abstractions over unsafe primitives.

## Formal Verification

### [[Capability Safety]] Properties
A system is capability-safe if:

1. **No Ambient Authority**: $\neg\exists o: \text{GloballyAccessible}(o)$
2. **Only Connectivity Begets Connectivity**: New capabilities can only be obtained through existing capabilities
3. **[[No Confused Deputy]]**: Authority is never exercised on behalf of others without explicit delegation

### [[Modal Logic]] Formalization
Using [[dynamic logic]] to express capability properties:

$$[\text{transfer}(c)]\text{CanAccess}(\text{recipient}, \text{target}(c))$$

"After transferring capability $c$, the recipient can access the target of $c$."

### [[Information Flow]] Analysis
Capability systems enable precise [[information flow]] tracking:

$$\text{InfoFlow}(o_1, o_2) \iff \exists \text{capability path from } o_1 \text{ to } o_2$$

## Economic Interpretation

### [[Property Rights]] Theory
Capabilities resemble [[property rights]] in economics:
- **Exclusive**: Only capability holders can exercise authority
- **Transferable**: Capabilities can be traded or gifted
- **Divisible**: Capabilities can be [[attenuated]] into lesser powers

### [[Market Mechanisms]]
Capability transfer can implement [[market-like]] resource allocation:

$$\text{Trade}(c_1, c_2) = (\text{transfer}(c_1, \text{party}_2), \text{transfer}(c_2, \text{party}_1))$$

### [[Coase Theorem]] Applications
In low-transaction-cost environments, capability systems enable efficient resource allocation regardless of initial capability distribution.

## Philosophical Foundations

### [[Ontological]] Perspective
Objects and capabilities form an [[ontologically]] unified framework - there is no distinction between "things" and "permissions to access things."

### [[Phenomenological]] Interpretation  
Capabilities mirror human [[intentionality]] - the ability to "mean" or "refer to" an object inherently carries the potential for interaction.

### [[Pragmatist]] Ethics
The object-capability principle embodies [[pragmatist]] ethics where authority is grounded in actual capability rather than abstract right or identity.

## Research Directions

### [[Capability Patterns]]
Development of [[design patterns]] that preserve capability discipline while enabling practical software development.

### [[Gradual Capability Systems]]
Research into [[gradual typing]]-inspired approaches for incrementally adopting capability discipline in existing codebases.

### [[Quantum Capabilities]]
Exploration of [[quantum information]] principles applied to capability systems, including [[quantum key distribution]] and [[quantum authentication]].

### [[Capability Calculi]]
Development of [[process calculi]] specifically designed for reasoning about capability-based concurrent systems.


---

preceding: [[architectural anti-patterns]]  


following: [[confused deputy]]

See also: [[resource allocation]]