---
date: 1716360354.879482
tags:
- autogenerated
- source__oai
- conversation_id__064ebe32-d02c-4250-93d2-41d608ad5446
- msg_aaa205f1-5aca-4319-9a28-398629ca7864
- msg_f8113927-88bb-40ae-8899-d5bf30bde5d2
- colorclass/philosophy-of-language
title: interaction combinators
---

**USER**

interaction combinators


**ASSISTANT**

Interaction combinators are a model of computation introduced by [[Yves Lafont]] in 1990. They are part of the broader field of interaction nets, which provide a graphical, parallel, and non-deterministic model of computation. Interaction combinators are notable for their simplicity and expressive power, making them a useful framework for exploring computational processes, including lambda calculus, logic programming, and beyond.

## Basic Concepts

### Interaction Nets

Interaction nets are a graphical model of computation where computation is represented as a graph of interacting agents. Each agent has a finite number of ports and a specific interaction rule that determines how it interacts with other agents.

### Agents and Ports

In the context of interaction combinators, there are three basic agents, each with three ports:

1. **$\epsilon$ (epsilon)**: The annihilation agent.
2. **$\delta$ (delta)**: The duplication agent.
3. **$\gamma$ (gamma)**: The permutation agent.

Each agent has a principal port and two auxiliary ports. The principal port is typically depicted with an arrow or a special symbol to distinguish it from auxiliary ports.

### Interaction Rules

The interaction rules define how agents interact when their principal ports are connected. The interaction of two agents produces a local rewriting of the graph, which can be interpreted as a computational step.

Here are the basic interaction rules for interaction combinators:

1. **Epsilon-Epsilon ($\epsilon$-$\epsilon$)**:
   $$
   (\epsilon, \epsilon) \rightarrow \emptyset
   $$
   When two epsilon agents interact, they annihilate each other, leaving an empty graph.

2. **Epsilon-Delta ($\epsilon$-$\delta$)**:
   $$
   (\epsilon, \delta) \rightarrow \emptyset
   $$
   When an epsilon agent interacts with a delta agent, they annihilate each other, similar to the epsilon-epsilon interaction.

3. **Epsilon-Gamma ($\epsilon$-$\gamma$)**:
   $$
   (\epsilon, \gamma) \rightarrow \emptyset
   $$
   When an epsilon agent interacts with a gamma agent, they annihilate each other as well.

4. **Delta-Gamma ($\delta$-$\gamma$)**:
   $$
   (\delta, \gamma) \rightarrow \text{reconfiguration}
   $$
   This interaction leads to a reconfiguration of the graph. The specific reconfiguration depends on the structure of the connected ports.

### Graphical Representation

Each agent is represented as a node in a graph with edges representing connections between ports. Computation proceeds by repeatedly applying interaction rules to connected agents, leading to a transformation of the graph.

## Example: Lambda Calculus Encoding

Interaction combinators can be used to encode and simulate lambda calculus. Here is a simple encoding of the lambda calculus terms using interaction combinators:

1. **Variables**: Represented as links in the graph.
2. **Application**: Represented by connecting two graphs corresponding to the function and argument.
3. **Abstraction**: Encoded using a specific configuration of interaction combinators that simulates variable binding and substitution.

### Example Encoding

Consider the lambda term \( \lambda x. x \):

- **Variable** \( x \) is represented by a link.
- **Abstraction** \( \lambda x. x \) is represented by a delta agent that duplicates the argument.

## Properties

### Confluence

Interaction combinators are confluent, meaning that the final result of computation does not depend on the order in which interaction rules are applied. This property is crucial for parallel and distributed computation.

### Expressiveness

Despite their simplicity, interaction combinators can encode various computational models, including lambda calculus, combinatory logic, and Turing machines. This makes them a powerful tool for theoretical computer science and the study of computation.

## Applications

### Parallel Computation

Interaction combinators provide a natural framework for parallel computation due to their graph-based nature and local interaction rules. Computation steps can be performed independently and in parallel, leading to efficient execution on parallel hardware.

### Proof Theory

In proof theory, interaction combinators are used to study the dynamics of proofs, particularly in the context of linear logic and proof nets. They provide a graphical representation of proofs and their transformations.

### Programming Languages

The principles of interaction combinators inspire the design of programming languages that emphasize parallelism and concurrency. Languages based on interaction nets allow for elegant expression of parallel algorithms.

## Conclusion

Interaction combinators are a fundamental model of computation with a rich theoretical foundation and practical applications in parallel computing, proof theory, and programming language design. Their simplicity, confluence, and expressiveness make them a valuable tool for exploring the dynamics of computation and the structure of algorithms.


---

preceding: [[mandelbrot's cascade model]]

See also: [[lambda calculus]]


See also: [[bend framework]]