---
date: 1727917106.820901
tags:
- autogenerated
- source__oai
- conversation_id__66fdeb95-c32c-8008-9a23-d10da96b1985
- msg_0e882516-ab10-482d-9f01-9fbbb45c19a9
- msg_6e3ccbf4-7153-45b6-8026-ef713cd69f92
- colorclass/edge-case
title: single responsibility principle
---

**USER**

single responsibility principle


**ASSISTANT**

The **Single Responsibility Principle (SRP)** is one of the five principles in the SOLID framework for object-oriented design. It states that a class or module should have **one, and only one, reason to change**, which means it should have a single responsibility or functionality. This principle is fundamental to creating software that is modular, maintainable, and extensible.

## Formal Definition of SRP

The formal definition of SRP is:
> "A class should have only one reason to change."

### Breaking Down the Principle

- **Single Responsibility:** The term "responsibility" refers to a specific set of behaviors or functionalities that a class encapsulates. When a class has more than one reason to change, it means it has multiple responsibilities.
- **Reason to Change:** A "reason to change" signifies that if a particular aspect of the software's functionality changes, it will directly affect the class in question. For instance, if a class handles both data formatting and file storage, changes in either data format or storage mechanism would require changes to the class.

### Why Use SRP?

Adhering to SRP provides multiple benefits:

1. **Improved Maintainability:** When a class has a single responsibility, understanding and modifying the code becomes easier because changes in one area do not propagate unwanted side effects.
2. **Enhanced Reusability:** Classes with a specific purpose are more likely to be reused in other parts of the application or in different projects.
3. **Simplified Testing:** A class with one responsibility is generally smaller and has fewer dependencies, making it easier to test in isolation.
4. **Reduced Coupling:** By limiting the responsibility of a class, it can minimize its dependency on other components, leading to a more modular and flexible codebase.

## Examples of SRP

### 1. **Violating SRP:**
Suppose we have a `User` class that handles various user-related tasks, such as storing user information, validating user input, and saving user data to a database.

```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

    def validate(self):
        # Validate user input
        if "@" not in self.email:
            raise ValueError("Invalid email")

    def save_to_database(self):
        # Code to save user to the database
        print(f"Saving {self.name} to the database")
```

Here, the `User` class has three responsibilities:
1. Holding user information (`name`, `email`).
2. Validating user data (`validate` method).
3. Saving data to the database (`save_to_database` method).

If any of these functionalities change (e.g., changing how validation works or using a different database), the `User` class needs to be modified, which violates SRP.

### 2. **Applying SRP:**
We can refactor the `User` class by separating the different responsibilities into their own classes:

```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email

class UserValidator:
    @staticmethod
    def validate(user):
        if "@" not in user.email:
            raise ValueError("Invalid email")

class UserRepository:
    @staticmethod
    def save(user):
        print(f"Saving {user.name} to the database")
```

Now, each class has a single responsibility:
- **`User`:** Holds user information.
- **`UserValidator`:** Handles the validation logic.
- **`UserRepository`:** Manages database interactions.

By adhering to SRP, changing one aspect (e.g., validation logic) will not affect the others, making the codebase easier to maintain and extend.

## How to Identify and Apply SRP

1. **Naming Conventions:** A class's name should indicate its purpose. If the name includes words like "and" or "or," it might be trying to handle multiple responsibilities (e.g., `UserManagerAndValidator`).
2. **Responsibility Check:** Ask yourself, "How many reasons could this class have to change?" If there are multiple reasons, the class likely has multiple responsibilities.
3. **Separation of Concerns:** Break down a class into smaller, more focused classes if it seems to handle more than one area of concern. Use design patterns like [[Dependency Injection]], [[Adapter Pattern]], or [[Facade Pattern|Facade]] to maintain separation while keeping the system cohesive.

## Related Principles

- **[[Open/Closed Principle (OCP)]]:** Classes should be open for extension but closed for modification. By following SRP, it's easier to extend a class's functionality through composition rather than modifying its internal logic.
- **[[Interface Segregation Principle (ISP)]]:** Similar to SRP but applies to interfaces. An interface should not force classes to implement methods they do not use, which aligns with the concept of keeping responsibilities separated.
- **Separation of Concerns:** A broader concept where the codebase is divided into distinct sections, each handling a specific aspect of the application.

In summary, the **Single Responsibility Principle** guides developers to create classes that focus on a single aspect of functionality, promoting cleaner, more manageable, and more adaptable software designs.


---

preceding: [[dependency injection]]  


following: [[dependency inversion principle]]

See also: [[side effects]]