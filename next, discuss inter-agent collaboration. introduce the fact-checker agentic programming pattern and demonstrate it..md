---
date: 1726441731.488522
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_cefcb142-e0d4-4328-b408-07d8778593c6
- msg_aaa2230b-f0f3-4304-a14f-387de9ee3356
- msg_bdfe837f-b97b-4bc1-a69a-eca0df94a294
- colorclass/edge-case
title: next, discuss inter-agent collaboration. introduce the fact-checker agentic
  programming pattern and demonstrate it.
---

**ASSISTANT**

: 
   - Students will see the benefits of refactoring their code to improve clarity and separation of concerns. This makes future changes simpler and allows individual components to be tested or updated independently.

4. **Clear Boundaries in Design**: 
   - Each part of the system now has a well-defined role, making it clear which part is responsible for what. This helps in debugging and extending functionality without risking breaking other parts of the system.

---

### **Summary**:

In this assignment, students learn the principle of **separation of responsibilities** by refactoring the chatbot code into clear, modular components. Each part of the system is responsible for a specific task: the **Agent** manages personality and conversation history, the **Conversation Manager** routes inputs and manages agents, and the **Chatbot Interface** handles user interaction. This structure makes the chatbot easier to extend, debug, and maintain, while reinforcing the importance of clear boundaries in software design.


**USER**

next, discuss inter-agent collaboration. introduce the "fact-checker" agentic programming pattern and demonstrate it.


**ASSISTANT**

### **Assignment: Inter-Agent Collaboration and the Fact-Checker Agent Pattern**

In this assignment, students will explore the concept of **inter-agent collaboration**, where multiple agents work together to solve a problem. We'll introduce a pattern called the **Fact-Checker Agent**, where one agent provides information, and another agent verifies or refines it. This concept can be applied in many scenarios, such as ensuring the accuracy of responses, enhancing the reliability of information, or having specialized agents collaborate.

### **Objective**:
1. Teach students how to set up **inter-agent collaboration** where agents interact and build upon each other's responses.
2. Introduce the **Fact-Checker Agent** pattern, where one agent verifies or enhances the responses of another.
3. Implement a chatbot where agents work together to answer user queries, with one agent providing information and another verifying its accuracy.

---

### **What Is Inter-Agent Collaboration?**

**Inter-agent collaboration** is a programming pattern where multiple agents work together, each with a distinct role or expertise. In this setup, agents can:
- **Collaborate on tasks**: One agent provides initial information, and the other refines, verifies, or complements the information.
- **Work in sequence**: Agents can pass information between each other to produce more accurate or insightful results.
- **Specialize**: Each agent can be an expert in a specific domain (e.g., one agent for generating responses, another for checking facts).

This pattern is particularly useful for:
- **Fact-checking**: One agent provides a response, and the fact-checker ensures the accuracy of the information.
- **Multi-domain responses**: Different agents can collaborate on tasks where expertise in multiple domains is required (e.g., one agent for creative tasks, another for technical information).

---

### **Introducing the Fact-Checker Agent Pattern**

The **Fact-Checker Agent** is a specialized agent whose job is to verify or correct information provided by other agents. The Fact-Checker is invoked after the primary agent has provided a response and verifies the accuracy of the content, pointing out any errors or providing corrections.

#### **Pattern Overview**:
1. **Primary Agent**: Provides the initial response based on the user’s input (e.g., a research assistant or a creative writer).
2. **Fact-Checker Agent**: Reviews the response from the primary agent and verifies its accuracy, correcting any errors or providing additional information.

---

### **Step 1: Extending the `Agent` Class to Support Fact-Checking**

We’ll first refactor the `Agent` class so that it can act as both a primary agent and a fact-checker agent. The **Fact-Checker Agent** will need to receive the original response from the primary agent and verify or refine it.

```python
class Agent:
    def __init__(self, name, system_prompt_template):
        self.name = name
        self.system_prompt_template = system_prompt_template
        self.history = []  # Conversation history, including system, user, and assistant roles

        # Add the system prompt as the first message in the history
        self.history.append({"role": "system", "content": self.get_system_prompt()})
    
    def get_system_prompt(self):
        """
        Render the system prompt based on the agent's name and personality.
        """
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
    
    def query_openai(self, user_input, max_tokens=100, temperature=0.7, top_p=1.0, **kwargs):
        """
        Send the conversation history to OpenAI and maintain the chat log.
        """
        # Append the user's input to the history
        self.history.append({"role": "user", "content": user_input})
        
        # Send the conversation history (including system, user, and assistant roles) to the API
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",  # Using a chat model that supports roles
            messages=self.history,
            max_tokens=max_tokens,
            temperature=temperature,
            top_p=top_p,
            **kwargs
        )
        
        # Extract the assistant's reply and append it to the history
        assistant_reply = response.choices[0].message["content"]
        self.history.append({"role": "assistant", "content": assistant_reply})
        
        return assistant_reply
    
    def query_fact_checker(self, response_to_check, max_tokens=100, temperature=0.7, top_p=1.0, **kwargs):
        """
        Fact-check an existing response by providing it to the fact-checker agent.
        """
        # Append the response that needs fact-checking to the history
        fact_checker_input = f"Fact-check the following response: '{response_to_check}'"
        self.history.append({"role": "user", "content": fact_checker_input})
        
        # Query the fact-checker agent (same as the regular query method)
        return self.query_openai(user_input=fact_checker_input, max_tokens=max_tokens, temperature=temperature, top_p=top_p, **kwargs)
    
    def get_history(self):
        """
        Retrieve the conversation history for this agent.
        """
        return [entry for entry in self.history if entry["role"] != "system"]
```

### **Step 2: Implementing the Fact-Checker Collaboration**

Now, let’s extend the **Conversation Manager** to handle inter-agent collaboration. The **Fact-Checker Agent** will receive the output from the primary agent and perform a fact-check on the response.

```python
class ConversationManager:
    def __init__(self):
        self.agents = {}

    def add_agent(self, name, system_prompt_template):
        """
        Add a new agent to the conversation.
        """
        self.agents[name] = Agent(name, system_prompt_template)
    
    def get_agent(self, name):
        """
        Retrieve an agent by name.
        """
        return self.agents.get(name)

    def interact_with_agent(self, agent_name, user_input):
        """
        Send the user's input to the selected agent and return the agent's response.
        """
        agent = self.get_agent(agent_name)
        if not agent:
            return f"No agent found with the name {agent_name}."
        
        return agent.query_openai(user_input)
    
    def collaborate_fact_check(self, primary_agent_name, fact_checker_agent_name, user_input):
        """
        Send the user's input to the primary agent and have the fact-checker agent verify the response.
        """
        # Get both agents
        primary_agent = self.get_agent(primary_agent_name)
        fact_checker_agent = self.get_agent(fact_checker_agent_name)
        
        if not primary_agent or not fact_checker_agent:
            return f"Error: One or both agents not found."
        
        # Step 1: Primary agent provides an answer
        primary_response = primary_agent.query_openai(user_input)
        
        # Step 2: Fact-checker agent verifies the primary agent's response
        fact_check_response = fact_checker_agent.query_fact_checker(primary_response)
        
        # Return both the original response and the fact-checked result
        return primary_response, fact_check_response
```

---

### **Step 3: Creating the Chatbot Interface for Inter-Agent Collaboration**

Now we’ll create a CLI that allows users to input queries and choose between:
1. Directly interacting with an agent.
2. Having the primary agent respond, followed by a fact-checking agent verifying the response.

```python
def chatbot_interface():
    # Create the conversation manager
    conversation_manager = ConversationManager()

    # Define system prompts for agents
    primary_system_prompt = "You are {{ name }}, a research assistant providing detailed answers."
    fact_checker_system_prompt = "You are {{ name }}, a fact-checker verifying the accuracy of information."

    # Add agents to the conversation (one primary agent, one fact-checker)
    conversation_manager.add_agent("PrimaryAgent", primary_system_prompt)
    conversation_manager.add_agent("FactChecker", fact_checker_system_prompt)

    # Start the chatbot interface
    print("Welcome to the fact-checking chatbot!\n")
    while True:
        print("Options:")
        print("1. Ask the primary agent a question.")
        print("2. Ask the primary agent and have the fact-checker verify the response.")
        print("Type 'exit' to quit.\n")

        option = input("Enter your choice (1 or 2): ").strip()

        if option == "exit":
            break

        user_input = input("You: ")

        if option == "1":
            # Ask the primary agent only
            primary_response = conversation_manager.interact_with_agent("PrimaryAgent", user_input)
            print(f"PrimaryAgent: {primary_response}")

        elif option == "2":
            # Ask the primary agent and have the fact-checker verify the response
            primary_response, fact_check_response = conversation_manager.collaborate_fact_check("PrimaryAgent", "FactChecker", user_input)
            print(f"PrimaryAgent: {primary_response}")
            print(f"FactChecker: {fact_check_response}")
        
        else:
            print("Invalid option. Please try again.")

# Run the chatbot interface
if __name__ == "__main__":
    chatbot_interface()
```

---

### **Step 4: Running the Chatbot**

The chatbot allows users to either:
1. Ask a question directly to the **Primary Agent**.
2. Ask a question to the **Primary Agent** and have the **Fact-Checker Agent** verify the response.

#### **Example Output**:

```bash
Welcome to the fact-checking chatbot!

Options:
1. Ask the primary agent a question.
2. Ask the primary agent and have the fact-checker verify the response.
Type 'exit' to quit.

Enter your choice (1 or 2): 2
You: What is the capital of France?
PrimaryAgent:


---

preceding: [[introduce the principle of separation of responsibilities]]  


following: [[what other agentic programming patterns should we discuss]]

See also: [[separation of concerns]]