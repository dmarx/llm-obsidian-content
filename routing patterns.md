---
date: 1726761765.765612
tags:
- autogenerated
- source__oai
- conversation_id__66ec4884-e8f8-8008-9848-d514fac221d6
- msg_aaa2143f-981a-43d8-82b7-e1f5ddfaa874
- msg_a63a5d92-0816-405f-8e27-adf3f0a3eaca
- colorclass/scatter-gather
title: routing patterns
---

**USER**

Routing Patterns


**ASSISTANT**

### Routing Patterns

**Routing Patterns** are a set of communication strategies in distributed systems where messages or requests are routed dynamically based on various criteria. These patterns define how messages are directed between producers and consumers, or between different services, allowing for flexibility, scalability, and robustness in complex architectures such as [[Microservices]], event-driven systems, and messaging middleware.

### Core Concepts

1. **Routing**: The process of determining the destination for a message or request based on its content, metadata, or predefined rules.
2. **Producer**: The entity or service that generates and sends the message.
3. **Consumer**: The entity or service that receives and processes the message.
4. **Router**: A component or system responsible for routing messages. This could be a message broker, middleware, or a load balancer.

### Types of Routing Patterns

1. **Content-Based Routing**
2. **Topic-Based Routing**
3. **Message Filter Pattern**
4. **Recipient List**
5. **Dynamic Router**
6. **Aggregator**
7. **Scatter-Gather (Routing Version)**

---

### 1. Content-Based Routing

**Content-Based Routing** is a pattern where messages are routed based on their content. This means that the message payload is inspected, and the message is routed to the appropriate consumer(s) based on rules that evaluate the content.

#### Example:
In a logistics system, a message containing shipment details is routed to different warehouses based on the destination city or country.

- **Message**: `{"type": "shipment", "destination": "New York"}`
- The router inspects the message and directs it to the New York warehouse service.

#### Formalization:

Let $m$ be the message with content $c(m)$ and $R$ be the router. The router applies a routing function $r(c(m))$ that determines the correct destination:

$$ r(c(m)) = \text{Consumer}_i $$

For example:

- If $c(m) = \text{destination: "New York"}$, then $r(c(m)) = \text{Warehouse New York}$.
- If $c(m) = \text{destination: "London"}$, then $r(c(m)) = \text{Warehouse London}$.

#### Use Cases:
- **E-commerce**: Route orders to different fulfillment centers based on the customer’s location.
- **Healthcare**: Route patient data to specific departments based on the type of treatment or condition.

### 2. Topic-Based Routing

**Topic-Based Routing** is commonly used in **publish-subscribe (Pub-Sub)** systems, where messages are published to a **topic**, and consumers subscribe to topics of interest. The router directs messages to consumers that have subscribed to the relevant topic.

#### Example:
In a monitoring system, messages related to CPU usage are routed to subscribers interested in performance metrics, while security alerts are routed to subscribers monitoring security incidents.

#### Formalization:

Let $P$ be the producer, $S_1, S_2, \dots, S_n$ be the subscribers, and $T$ be a topic. The producer publishes a message $m$ to the topic:

$$ P \xrightarrow{m} T $$

The router delivers the message to all consumers subscribed to the topic $T$:

$$ T \xrightarrow{m} S_1, S_2, \dots, S_k $$

#### Use Cases:
- **News Feeds**: Route news articles to consumers based on topics like sports, politics, or entertainment.
- **Event-Driven Architectures**: Microservices communicate by publishing events to topics, with other services subscribing to the topics of interest.

### 3. Message Filter Pattern

The **Message Filter** pattern allows consumers to filter and process only messages they are interested in, based on content or metadata. The router applies filtering logic and discards or ignores messages that do not meet certain criteria.

#### Example:
A financial system generates transaction logs for auditing purposes. Only transactions above a certain amount ($10,000, for example) are routed to a special auditing service.

#### Formalization:

Let $m$ be the message and $f(m)$ be the filtering function applied by the router. If the filter condition is met, the message is routed to the consumer:

$$ f(m) = \begin{cases}
\text{true}, & \text{route to consumer} \\
\text{false}, & \text{discard}
\end{cases} $$

For example, if $m = \text{"transaction amount: $15,000"}$ and $f(m) = \text{transaction amount} > 10,000$, the message is routed.

#### Use Cases:
- **Auditing Systems**: Filter and route only high-risk or high-value transactions for further processing.
- **Error Handling**: Route only messages that contain errors to error-handling services.

### 4. Recipient List

The **Recipient List** pattern allows a message to be routed to multiple recipients based on predefined routing logic. This is useful when the same message needs to be processed by multiple services.

#### Example:
In an order processing system, a new order might need to be sent to the inventory service to update stock levels, the billing service for payment processing, and the shipping service for delivery.

#### Formalization:

Let $m$ be the message and $R$ the router. The router maintains a recipient list $L$:

$$ R(m) = \{ \text{Consumer}_1, \text{Consumer}_2, \dots, \text{Consumer}_n \} $$

For example, the router sends the same message $m$ to both the inventory and billing services:

$$ R(m) = \{ \text{Inventory Service}, \text{Billing Service} \} $$

#### Use Cases:
- **Order Processing**: Route new orders to multiple services such as inventory, billing, and shipping.
- **Notification Systems**: Route event notifications to multiple channels, such as email, SMS, and push notifications.

### 5. Dynamic Router

The **Dynamic Router** pattern allows routing decisions to change dynamically based on the current system state or conditions. Unlike static routing rules, dynamic routers evaluate the system’s context (e.g., load, availability, or external factors) before deciding the route.

#### Example:
A dynamic router in a microservices architecture can route requests to different instances of a service based on load or geographic location.

#### Formalization:

Let $s$ be the system state and $m$ the message. The router evaluates a routing function $r(c(m), s)$ based on both message content and system state:

$$ r(c(m), s) = \text{Consumer}_i $$

For example:

- If $s = \text{service load high}$, route to a different instance.
- If $s = \text{region: "Europe"}$, route to the European data center.

#### Use Cases:
- **Load Balancing**: Route traffic dynamically based on server load or network conditions.
- **Geo-Routing**: Route requests to the nearest or most appropriate data center based on geographic location.

### 6. Aggregator

The **Aggregator** pattern collects multiple related messages or data from different sources and aggregates them into a single message or result. The router waits for all the necessary data to arrive before forwarding it to the final consumer.

#### Example:
In a distributed system where multiple services provide parts of the data for a report, the aggregator collects responses from all services, compiles the data, and then forwards the final report to the client.

#### Formalization:

Let $m_1, m_2, \dots, m_n$ be the messages that need to be aggregated. The router collects and aggregates the messages:

$$ R(m_1, m_2, \dots, m_n) = \text{Aggregate}(m_1, m_2, \dots, m_n) $$

For example, data from multiple microservices is collected and combined into a single report:

$$ R(m_1, m_2) = m_1 \cup m_2 $$

#### Use Cases:
- **Data Aggregation**: Collect data from multiple microservices to produce a combined report.
- **Search Systems**: Aggregate search results from multiple databases or indexes.

### 7. Scatter-Gather (Routing Version)

The **Scatter-Gather** pattern is a routing mechanism where a message is scattered to multiple recipients, and their responses are gathered and aggregated. This is useful in parallel processing, where multiple services process different parts of a task concurrently.

#### Example:
In a distributed search system, a search query is sent to multiple databases or indexes, and the results are gathered and merged before being returned to the client.

#### Formalization:

Let $C$ be the client and $S_1, S_2, \dots, S_n$ be the services. The message $m$ is scattered to all services, and the responses $r_1, r_2, \dots, r_n$ are gathered:

$$ C \xrightarrow{m} S_1, S_2, \dots, S_n $$

The router aggregates the responses:

$$ R = \text{Aggregate}(r_1, r_2, \dots, r_n) $$

#### Use Cases:
- **Distributed Queries**: Send queries to multiple databases and aggregate the results.
- **Parallel Processing**: Scatter tasks to multiple services for parallel processing and aggregate the results.

---

### Conclusion

**Routing Patterns** provide a flexible, scalable way to direct messages or requests in distributed systems. Each pattern offers unique strategies for routing based on content, topics, recipients, or dynamic conditions. Popular patterns like **Content-Based Routing**, **Topic-Based Routing**, and **Recipient List** are essential in event-driven architectures, while advanced patterns like **Dynamic Router** and **Aggregator** help manage system complexity and optimize performance. These patterns


---

preceding: [[command query responsibility segregation]]  


following: [[topic-based routing]]