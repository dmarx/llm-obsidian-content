---
date: 1726441393.905411
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_84d7d9ff-6860-4116-bf7e-06d0999201dd
- msg_aaa2eb5f-e761-4a07-a21d-a08ae1d7268e
- msg_490c9350-e204-45d2-a7ff-1f2afc9e80b3
- colorclass/edge-case
title: assignment per-agent personalities
---

**ASSISTANT**

the model to provide responses that are aware of the entire conversation context.
- **System prompt** establishes the assistant’s behavior (e.g., being an educational tutor), while **roles** (`user`, `assistant`, `system`) ensure structured communication.

---

### **Key Learning Points**:

1. **System Prompts**:
   - Define the assistant’s behavior and role.
   - Useful for customizing the model’s tone and guiding its responses.

2. **Roles in LLMs**:
   - **System**: Provides the initial guidance or personality to the model.
   - **User**: Represents the human’s input in the conversation.
   - **Assistant**: Represents the AI’s response to the user.

3. **Context and Session Persistence**:
   - Conversation history (with roles) can be submitted to the API to maintain context across multiple interactions.
   - This enables the model to provide more consistent and relevant responses based on the entire conversation history.

4. **CLI Chatbot**:
   - The student now has a functional CLI chatbot that maintains session-persistent conversation history using roles and system prompts.

---

### **Summary**:

In this assignment, students learned about **system prompts**, **roles** in LLM interactions, and how to maintain a **session-persistent conversation** by sending the conversation history (with roles) back to the API. This practical, step-by-step approach introduces the fundamentals of building a role-based chatbot and shows how conversation history enhances the context-awareness of LLM-based applications.


**USER**

assignment: per-agent personalities


**ASSISTANT**

### **Assignment: Implementing Per-Agent Personalities**

In this assignment, students will build on their understanding of **system prompts** and **roles** to implement **per-agent personalities**. Each agent will have a unique personality that defines how it interacts with users. These personalities will be defined through customizable **system prompts**, which dictate the tone, behavior, and expertise of each agent.

### **Objective**:
1. Create multiple agents, each with a unique **personality** driven by a system prompt.
2. Implement personality-specific behaviors that guide the tone, style, or domain knowledge of the agent.
3. Demonstrate how different agents respond to the same input based on their personalities.
4. Extend the chatbot to allow users to choose which agent they want to interact with.

---

### **Step 1: Defining Per-Agent Personalities**

We'll start by giving each agent a distinct personality through its system prompt. These system prompts will define the **role** of the agent and how it behaves during the conversation. Each agent will have a different personality, such as being formal, casual, or expert in a particular field.

#### **Personality-Based System Prompts**:
1. **Alice (Research Assistant)**:
   - Focused, factual, and precise.
   - "You are {{ name }}, a research assistant. Provide detailed, factual answers with references where possible."
   
2. **Bob (Creative Writer)**:
   - Imaginative, playful, and creative.
   - "You are {{ name }}, a creative writing assistant. Respond with playful, imaginative, and creative writing."

3. **Charlie (Friendly Chatbot)**:
   - Casual, friendly, and approachable.
   - "You are {{ name }}, a friendly chatbot. Respond in a casual and approachable tone, as if having a light-hearted conversation with a friend."

---

### **Step 2: Updating the `Agent` Class to Support Personalities**

We’ll use the existing `Agent` class, but with distinct system prompts for each agent. These system prompts define their **personalities**.

```python
import openai
from jinja2 import Template

# Define the Agent class with personality-driven system prompts
class Agent:
    def __init__(self, name, system_prompt_template):
        self.name = name
        self.system_prompt_template = system_prompt_template
        self.history = []  # Initialize the conversation history

        # Add the system prompt as the first message in the history
        self.history.append({"role": "system", "content": self.get_system_prompt()})
    
    def get_system_prompt(self):
        """
        Render the system prompt based on the agent's name and personality.
        """
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
    
    def query_openai(self, user_input, max_tokens=100, temperature=0.7, top_p=1.0, **kwargs):
        """
        Send the conversation history to OpenAI and maintain the chat log.
        """
        # Append the user's input to the history
        self.history.append({"role": "user", "content": user_input})
        
        # Send the conversation history (including system, user, and assistant roles) to the API
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",  # Using a chat model that supports roles
            messages=self.history,
            max_tokens=max_tokens,
            temperature=temperature,
            top_p=top_p,
            **kwargs
        )
        
        # Extract the assistant's reply and append it to the history
        assistant_reply = response.choices[0].message["content"]
        self.history.append({"role": "assistant", "content": assistant_reply})
        
        return assistant_reply
    
    def get_history(self):
        """
        Retrieve the conversation history for this agent.
        """
        return [entry for entry in self.history if entry["role"] != "system"]
```

### **Step 3: Implementing Per-Agent Interaction in the CLI**

Next, we will create multiple agents with different personalities, and let users choose which agent they want to interact with.

```python
# Define system prompt templates for each agent
alice_system_prompt = "You are {{ name }}, a research assistant. Provide detailed, factual answers with references where possible."
bob_system_prompt = "You are {{ name }}, a creative writing assistant. Respond with playful, imaginative, and creative writing."
charlie_system_prompt = "You are {{ name }}, a friendly chatbot. Respond in a casual and approachable tone, as if having a light-hearted conversation with a friend."

# Create agents with different personalities
agents = {
    "Alice": Agent(name="Alice", system_prompt_template=alice_system_prompt),
    "Bob": Agent(name="Bob", system_prompt_template=bob_system_prompt),
    "Charlie": Agent(name="Charlie", system_prompt_template=charlie_system_prompt)
}

# Simple CLI interface to choose and interact with an agent
def chatbot():
    print("Welcome to the multi-agent chatbot!\n")
    print("Choose an agent to chat with:")
    for agent_name in agents:
        print(f"- {agent_name}")
    print()

    # Let the user choose which agent to interact with
    chosen_agent_name = input("Enter the agent's name (e.g., Alice, Bob, Charlie): ").strip()
    agent = agents.get(chosen_agent_name)

    if not agent:
        print("Invalid agent name. Please try again.")
        return
    
    print(f"\nYou are now chatting with {agent.name}. Type 'exit' to quit.\n")

    # Start the conversation loop
    while True:
        user_input = input("You: ")
        
        if user_input.lower() == "exit":
            break
        
        # Send the user's input to the chosen agent and get the response
        response = agent.query_openai(user_input=user_input, max_tokens=100)
        print(f"{agent.name}: {response}")

    # Display conversation history
    print("\nConversation History:")
    for entry in agent.get_history():
        print(f"{entry['role'].capitalize()}: {entry['content']}")

# Run the chatbot
if __name__ == "__main__":
    chatbot()
```

### **Step 4: Running the Chatbot**

When you run the script, it will allow you to choose an agent (with a different personality) and start chatting with them. The agents will respond based on the tone and style set by their system prompts.

#### **Example Interaction**:
```bash
Welcome to the multi-agent chatbot!

Choose an agent to chat with:
- Alice
- Bob
- Charlie

Enter the agent's name (e.g., Alice, Bob, Charlie): Bob

You are now chatting with Bob. Type 'exit' to quit.

You: Can you tell me a story?
Bob: Sure! Once upon a time, in a faraway land, there lived a dragon who loved to bake cookies...

You: Write me a poem about the stars.
Bob: The stars above, so bright and high, Like diamonds shining in the sky...

You: exit

Conversation History:
User: Can you tell me a story?
Assistant: Sure! Once upon a time, in a faraway land, there lived a dragon who loved to bake cookies...
User: Write me a poem about the stars.
Assistant: The stars above, so bright and high, Like diamonds shining in the sky...
```

### **Explanation**:

1. **Agent Personalities**:
   - Each agent has a unique system prompt that defines its personality and role. For example, Bob is a creative writer, so his responses are playful and imaginative.
   
2. **System Prompt in Action**:
   - The system prompt guides the assistant’s responses without appearing in the conversation history. Each agent's responses reflect their distinct tone and behavior.

3. **Conversation History**:
   - The conversation history is maintained for each agent, and users can review the interaction after they exit.

---

### **Tips for Authoring System Prompts for Agent Personalities**:

1. **Clearly Define the Role**:
   - Make sure the system prompt clearly defines the agent’s role, so the assistant knows how to respond appropriately.
   
2. **Be Consistent in Tone**:
   - Use language that matches the tone you want the agent to adopt (e.g., playful, formal, casual).
   
3. **Specialize Agents**:
   - Assign specific domains or expertise to agents. For example, Alice could be a research expert, Bob a creative assistant, and Charlie a friendly chatbot.

4. **Balance Instructions**:
   - Provide enough detail in the system prompt to guide the assistant, but don’t overload it with too many rules, which might confuse the model.

---

### **Learning Outcomes**:

1. **Understanding System Prompts**:
   - Students learn how to use system prompts to define distinct personalities for each agent, shaping how they respond to user input.
   
2. **Using Lists and Classes**:
   - Students practice managing multiple agents using a dictionary of agent instances, each with its own conversation history.

3. **Customizing Agent Behavior**:
   - By modifying the system prompts, students can experiment with different tones, styles, and expertise areas for their agents, making each interaction unique.

4. **Maintaining Conversation History**:
   - Students reinforce their understanding of list manipulation and how to maintain conversation logs that reflect the user and assistant interactions.

---

### **Assignment Extension (Optional)**:

1. **Multiple Agents in One Session**:
   - Extend the chatbot to allow users to switch between agents during the same session, retaining the conversation history for each agent.

2. **Personality Switch**:
   - Allow agents to change their personality mid-conversation by updating their system prompt dynamically.

3. **More Advanced Personalities**:
   - Experiment with more complex system prompts, such as instructing an agent to


---

preceding: [[we glossed over system prompt previously. let's dive deeper into what that is, how it works, what to expect with respect to pre-existing system prompts embedded in product apis the learner may interac]]  


following: [[introduce the principle of separation of responsibilities]]