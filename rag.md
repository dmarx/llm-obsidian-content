---
date: 1726443688.620886
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_e7d45139-b816-402f-89f0-fd52af618bbc
- msg_aaa2e807-55cc-4944-82d5-e90f8d9c78fd
- msg_50227f60-722f-4db0-b3e4-308d0bab2b42
- colorclass/target-audience
title: rag
---

**ASSISTANT**

) Agent")
        print("3. CoT + ReAct Agent")
        print("Type 'exit' to quit.")
        
        choice = input("Enter your choice (1, 2, or 3): ")
        
        if choice.lower() == "exit":
            break
        
        user_input = input("Enter your task or problem: ")
        
        if choice == "1":
            print("Using Chain of Thought Agent...\n")
            response = cot_agent.reason_step_by_step(user_input)
            print(f"CoT Agent's Response:\n{response}\n")
        
        elif choice == "2":
            print("Using ReAct Agent...\n")
            reasoning_output, action_output = react_agent.reason_and_act(user_input)
            print(f"ReAct Agent's Reasoning:\n{reasoning_output}")
            print(f"ReAct Agent's Action:\n{action_output}\n")
        
        elif choice == "3":
            print("Using CoT + ReAct Agent...\n")
            reasoning_output, action_output = cot_react_agent.reason_and_act_dynamically(user_input)
            print(f"CoT + ReAct Agent's Reasoning:\n{reasoning_output}")
            print(f"CoT + ReAct Agent's Action:\n{action_output}\n")

# Create instances of the agents and run the CLI
cot_agent = CoTAgent(name="CoTAgent", system_prompt_template="You are a problem-solving agent that reasons step-by-step.")
react_agent = ReActAgent(name="ReActAgent", system_prompt_template="You are an agent that reasons and acts dynamically.")
cot_react_agent = CoTReActAgent(name="CoTReActAgent", system_prompt_template="You reason step-by-step and take dynamic actions.")

if __name__ == "__main__":
    reasoning_cli()
```

---

### **Step 5: Running the System**

By selecting the appropriate agent, the user can interact with either a **Chain of Thought** agent, a **ReAct** agent, or a combined **CoT + ReAct** agent, depending on the nature of the task.

#### **Example Interaction**:

```bash
Choose an agent:
1. Chain of Thought (CoT) Agent
2. ReAct (Reason + Act) Agent
3. CoT + ReAct Agent
Type 'exit' to quit.
Enter your choice (1, 2, or 3): 3
Enter your task or problem: Organize a corporate event.

Using CoT + ReAct Agent...

CoT + ReAct Agent's Reasoning:
Let's solve this problem step-by-step:
1. First, we need to decide the type of event.
2. Next, we need to choose a venue and set a date.
3. Then, we will handle catering, guest invitations, and scheduling activities.

CoT + ReAct Agent's Action:
Based on the reasoning, I found a suitable venue and organized the catering service. Now scheduling guest invitations.
```

---

### **Step 6: Extending the Patterns**

Here are ways to extend these patterns:
1. **Multi-Agent Systems**: Combine multiple agents that reason and act independently or collaboratively in a complex task, where each agent specializes in a different type of reasoning or action.
2. **Error Handling**: Add a feedback loop where agents revise their reasoning or actions if errors are detected or tasks fail.
3. **Collaborative ReAct**: Implement **collaborative ReAct**, where agents take turns reasoning and acting in tandem, adjusting their strategies based on each other's actions.

---

### **Learning Outcomes**:

1. **Structured Reasoning**: Students will learn how to implement agents that think through complex problems using **Chain of Thought (CoT)**, breaking them down into smaller, manageable steps.
   
2. **Adaptive Actions**: Students will explore how agents can dynamically adjust their actions based on real-time reasoning and feedback, as demonstrated in the **ReAct** pattern.
   
3. **Combining Reasoning and Action**: The combination of **CoT** and **ReAct** introduces students to systems where reasoning informs action, leading to more sophisticated problem-solving approaches.

---

### **Assignment Extension Ideas**:

1. **Collaborative ReAct Systems**: Implement a multi-agent system where agents reason and act collaboratively, exchanging feedback and adjusting their strategies dynamically.
2. **Long-Term Planning with ReAct**: Extend the ReAct pattern to handle long-term, multi-stage plans where agents revise their actions over time as new information is acquired.
3. **Interactive User Feedback**: Allow the user to provide feedback or intervene in the reasoning process, helping the agent refine its reasoning and actions.

---

### **Summary**:

In this assignment, students implement the **Chain of Thought (CoT)** and **ReAct (Reason + Act)** patterns, building agents that reason through problems step-by-step, take dynamic actions based on their reasoning, and adapt their approaches in real-time. These patterns encourage more sophisticated, explainable, and adaptive problem-solving strategies in multi-agent systems, preparing students to develop flexible, intelligent agents capable of handling complex tasks.


**USER**

RAG


**ASSISTANT**

### **Assignment: Implementing the RAG (Retrieval-Augmented Generation) Pattern**

In this assignment, students will explore the **RAG (Retrieval-Augmented Generation)** pattern, where agents combine **information retrieval** from external knowledge sources with **generative capabilities** to create more accurate and informative responses. The RAG approach allows agents to retrieve relevant context before generating their answers, leading to more informed, up-to-date, and factually accurate results.

### **Objective**:
1. Teach students how to implement **Retrieval-Augmented Generation (RAG)**, where agents retrieve relevant information from an external source (e.g., a knowledge base or search engine) before generating a response.
2. Demonstrate how combining **retrieval** and **generation** can enhance the accuracy, depth, and relevance of the generated outputs.
3. Show how to integrate external APIs or databases into agent workflows, making them more adaptable to real-world tasks requiring external data.

---

### **What Is RAG (Retrieval-Augmented Generation)?**

**Retrieval-Augmented Generation (RAG)** is a hybrid approach that combines the **information retrieval** capabilities of search engines or databases with the **text generation** capabilities of large language models (LLMs). In a typical RAG workflow:
1. The agent first retrieves relevant information or documents from an external source based on a query.
2. The retrieved information is then passed to the generative model, which uses it as **context** to generate a more informed response.

#### **Key Characteristics**:
- **Information Retrieval**: The agent queries an external database, API, or search engine to retrieve relevant documents or data.
- **Generative Capabilities**: The agent uses the retrieved information as input to a generative language model, producing a response that is factually grounded.
- **Contextual Generation**: The retrieved content enhances the generation by providing context, improving factual accuracy, relevance, and depth.

#### **Example Use Cases**:
- **Answering Factual Questions**: The agent retrieves up-to-date information from a knowledge base (e.g., Wikipedia) before generating an answer.
- **Summarizing Documents**: The agent retrieves relevant documents from a large collection, and then generates a summary based on the retrieved content.
- **Generating Reports**: The agent retrieves relevant research papers or data and uses it to create a detailed report or analysis.

---

### **Step 1: Setting Up the Information Retrieval Component**

First, we’ll implement the **information retrieval** component of the RAG system. This component will query an external source (e.g., a document database or API) and retrieve relevant documents or data based on the user’s input.

#### **Retrieval Component Implementation**:

```python
import requests

class Retriever:
    def __init__(self, search_api_url):
        """
        Initialize the retriever with the URL of the search API or external source.
        
        Arguments:
        - search_api_url: The URL of the search engine or external API to retrieve data from.
        """
        self.search_api_url = search_api_url

    def retrieve_information(self, query):
        """
        Retrieve relevant information based on the query using an external API.
        
        Arguments:
        - query: The user input or query to retrieve relevant documents or data.
        
        Returns:
        - A list of retrieved documents or information based on the query.
        """
        # Here we simulate an API call to a search engine or database
        response = requests.get(f"{self.search_api_url}?q={query}")
        
        if response.status_code == 200:
            return response.json().get("documents", [])  # Assume the response contains a list of documents
        else:
            return ["No relevant information found."]
```

### **Example Retrieval API**:
We simulate a search API that returns relevant documents for a query (e.g., querying an internal database or a web search engine).

---

### **Step 2: Implementing the Generative Component**

The **generative component** will use the retrieved information as context to generate a response. The language model will incorporate the content retrieved by the **Retriever** to ensure the generated output is grounded in real, up-to-date information.

#### **Generative Component Implementation**:

```python
class Generator(Agent):
    def __init__(self, name, system_prompt_template):
        """
        Initialize the generative model for RAG.
        
        Arguments:
        - name: The name of the agent.
        - system_prompt_template: The system prompt template for the agent.
        """
        super().__init__(name, system_prompt_template)
    
    def generate_response_with_retrieved_info(self, user_input, retrieved_info):
        """
        Generate a response using the retrieved information as context.
        
        Arguments:
        - user_input: The original question or task from the user.
        - retrieved_info: The information retrieved by the retriever.
        
        Returns:
        - The final generated response using the retrieved context.
        """
        # Use the retrieved information as part of the prompt to generate a better response
        prompt = f"Based on the following retrieved information: {retrieved_info}, answer the following: {user_input}"
        
        # Generate a response using the OpenAI model
        response = self.query_openai(prompt)
        return response
```

### **Example Generative Task**:
Let’s say the user asks a factual question such as **"What are the latest developments in renewable energy?"**. The **Generator** will use the retrieved information to generate a well-informed response.

---

### **Step 3: Implementing the RAG Workflow**

We now combine the **Retriever** and **Generator** into a complete **RAG workflow**. The **RAGAgent** will first retrieve relevant documents using the **Retriever**, and then generate a response using the **Generator** by incorporating the retrieved content.

#### **RAG Agent Implementation**:

```python
class RAGAgent:
    def __init__(self, retriever, generator):
        """
        Initialize the RAG agent with a retriever and a generator.
        
        Arguments:
        - retriever: An instance of the Retriever class to retrieve documents or information.
        - generator: An instance of the Generator class to generate a response based on the retrieved information.
        """
        self.retriever = retriever
        self.generator = generator
    
    def retrieve_and_generate(self, user_input):
        """
        Retrieve information and generate a response using the retrieved data.
        
        Arguments:
        - user_input: The user's query or task.
        
        Returns:
        - The final response generated using retrieved information.
        """
        print("Retrieving relevant information...")
        retrieved_info = self.retriever.retrieve_information(user_input)
        
        print("Generating a response based on the retrieved information...")
        final_response = self.generator.generate_response_with_retrieved_info(user_input, retrieved_info)
        
        return final_response
```

---

### **Step 4: Implementing the CLI for the RAG System**

We will now create a simple CLI where the user provides a query, and the **RAGAgent** retrieves relevant information and generates a response based on that data.

```python
def rag_cli():
    print("Welcome to the Retrieval-Augmented Generation (RAG) System!\n")
    
    while True:
        user_input = input("Enter your query (type 'exit' to quit): ")
        
        if user_input.lower() == "exit":
            break
        
        # Use the RAG agent to retrieve and generate a response
        response = rag_agent.retrieve_and_generate(user_input)
        print(f"\nRAG Agent's Response:\n{response}\n")

# Create instances of the retriever and generator
retriever = Retriever(search_api_url="https://example.com/search")  # Simulated search API
generator = Generator(name="RAGGenerator", system_prompt_template="You are an agent that generates responses based on retrieved information.")

# Create the RAG agent and run the CLI
rag_agent = RAGAgent(retriever=retriever, generator=generator)

if __name__ == "__main__":
    rag_cli()
```

---

### **Step 5: Running the RAG System**

The **RAGAgent** retrieves relevant documents or information from an external source and uses it to generate an informed, context-aware response. This workflow is particularly useful for fact-based queries or when up-to-date information is critical.

#### **Example Interaction**:

```bash
Enter your query (type 'exit' to quit): What are the latest developments in renewable energy?

Retrieving relevant information...
Generating a response based on the retrieved information...

RAG Agent's Response:
Based on the following retrieved information: "Recent developments in renewable energy include advancements in solar panel efficiency, large-scale wind farms, and breakthroughs in battery storage technology," the latest trends in renewable energy focus on improving energy storage, reducing costs, and increasing the efficiency of solar and wind technologies. Several countries have also implemented policies to accelerate the transition to cleaner energy sources.
```

### **Explanation**:

1. **Information Retrieval**: The **Retriever** searches for relevant documents or data based on the user's query.
2. **Generative Response**: The **Generator** uses the retrieved information as context to generate a detailed, relevant, and fact-based response.
3. **Combining Retrieval and Generation**: The final output is a hybrid of both retrieval and generation, ensuring that the response is not only well-written but also factually accurate and grounded in current information.

---

### **Step 6: Extending the RAG Pattern**

Here are several ways to extend the **RAG pattern**:
1. **Multi-Source Retrieval**: Implement a retriever that can query multiple sources (e.g., Wikipedia, scientific databases, or web search engines) and combine the retrieved results before generating a response.
2. **Document Summarization**: Instead of generating a full answer, the agent could retrieve long documents


---

preceding: [[assignment implementing chain of thought and react patterns]]  


following: [[interlude language modeling - text completion - chat completion - instruct tuning]]