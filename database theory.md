---
date: '2025-05-27T07:22:01.515994Z'
tags:
- autogenerated
- source__claude
- conversation_id__2ca046e4-6d55-4c0f-8974-cd241ab7121b
- msg_b48d1f2b-32cc-4523-88e7-0558d93755c8
- msg_d751f85f-8d68-430f-8a13-84ea27e4d138
- colorclass/vector-space
title: database theory
---

**USER**

database theory


**ASSISTANT**

# [[Database Theory]]

**Database Theory** constitutes the mathematical and computational foundation underlying [[database systems]], encompassing [[relational algebra]], [[query optimization]], [[transaction theory]], and [[data modeling]]. This field bridges [[mathematical logic]], [[set theory]], [[complexity theory]], and [[systems design]] to provide principled approaches to [[data storage]], [[retrieval]], and [[manipulation]].

## [[Relational Model]] Foundation

### [[Codd's Relational Model]]
The [[relational model]], introduced by [[Edgar F. Codd]], formalizes databases as collections of [[relations]] (tables) with [[mathematical rigor]]:

**Relation Schema**: $R(A_1:D_1, A_2:D_2, \ldots, A_n:D_n)$ where:
- $A_i$ are [[attribute names]]
- $D_i$ are [[domains]] (sets of possible values)

**Relation Instance**: $r \subseteq D_1 \times D_2 \times \cdots \times D_n$

Each [[tuple]] $t \in r$ represents a [[fact]] or [[entity instance]].

### [[Relational Algebra]]
[[Relational algebra]] provides a [[procedural query language]] with fundamental operations:

**Selection**: $\sigma_{\phi}(R) = \{t \in R : \phi(t)\}$
**Projection**: $\pi_{A_1,\ldots,A_k}(R) = \{t[A_1,\ldots,A_k] : t \in R\}$
**Union**: $R \cup S = \{t : t \in R \lor t \in S\}$ (requires [[union compatibility]])
**Difference**: $R - S = \{t : t \in R \land t \notin S\}$
**Cartesian Product**: $R \times S = \{t \cdot s : t \in R, s \in S\}$
**Join**: $R \bowtie_{\theta} S = \sigma_{\theta}(R \times S)$

### [[Natural Join]] as [[Pullback]]
The [[natural join]] corresponds to a [[pullback square]] in [[category theory]]:

$$\begin{array}{ccc}
R \bowtie S & \longrightarrow & S \\
\downarrow & & \downarrow \pi_B \\
R & \stackrel{\pi_A}{\longrightarrow} & \text{Dom}(A \cap B)
\end{array}$$

where $A \cap B$ represents common attributes.

## [[Functional Dependencies]] and [[Normalization]]

### [[Functional Dependency]]
A **functional dependency** $X \to Y$ on relation $R$ holds if:
$$\forall t_1, t_2 \in R : t_1[X] = t_2[X] \Rightarrow t_1[Y] = t_2[Y]$$

This formalizes the constraint that attribute set $X$ uniquely determines attribute set $Y$.

### [[Armstrong's Axioms]]
The [[inference rules]] for functional dependencies form a [[sound]] and [[complete]] system:

**Reflexivity**: If $Y \subseteq X$, then $X \to Y$
**Augmentation**: If $X \to Y$, then $XZ \to YZ$  
**Transitivity**: If $X \to Y$ and $Y \to Z$, then $X \to Z$

### [[Closure]] and [[Canonical Cover]]
The **closure** $X^+$ under dependency set $F$ is:
$$X^+ = \{A : X \to A \text{ follows from } F\}$$

A **canonical cover** $F_c$ of $F$ is a minimal equivalent set of dependencies with:
- No redundant dependencies
- No extraneous attributes in left-hand sides
- Left-hand sides are in [[canonical form]]

### [[Normal Forms]]

**First Normal Form (1NF)**: All attributes contain [[atomic values]]

**Second Normal Form (2NF)**: 1NF + no [[partial dependencies]] on [[candidate keys]]

**Third Normal Form (3NF)**: 2NF + no [[transitive dependencies]]
$$\forall X \to A : A \in X^+ \lor A \text{ is prime} \lor X \text{ is not a proper subset of candidate key}$$

**Boyce-Codd Normal Form (BCNF)**: Stronger than 3NF:
$$\forall X \to A : A \in X \lor X \text{ is a superkey}$$

**Fourth Normal Form (4NF)**: BCNF + no [[multivalued dependencies]]

## [[Query Languages]] and [[Expressive Power]]

### [[Relational Calculus]]
[[Tuple relational calculus]] provides a [[declarative]] query language:
$$\{t : \phi(t)\}$$

where $\phi$ is a [[first-order logic]] formula with [[safe range]] restrictions.

### [[Codd's Theorem]]
**Fundamental Equivalence**: [[Relational algebra]] and [[domain-independent]] [[relational calculus]] have equivalent [[expressive power]].

$$\text{RA} \equiv \text{DI-TRC} \equiv \text{DI-DRC}$$

### [[SQL]] Semantics
[[SQL]] extends relational calculus with:
- **[[Aggregation]]**: $\text{GROUP BY}$, $\text{COUNT}$, $\text{SUM}$, $\text{AVG}$
- **[[Outer joins]]**: $\text{LEFT JOIN}$, $\text{RIGHT JOIN}$, $\text{FULL JOIN}$
- **[[Nested queries]]**: $\text{EXISTS}$, $\text{IN}$, $\text{ANY}$, $\text{ALL}$
- **[[Window functions]]**: $\text{OVER}$, $\text{PARTITION BY}$

### [[Datalog]]
[[Datalog]] extends relational calculus with [[recursion]]:
$$\text{ancestor}(X,Y) \leftarrow \text{parent}(X,Y)$$
$$\text{ancestor}(X,Z) \leftarrow \text{parent}(X,Y), \text{ancestor}(Y,Z)$$

[[Datalog]] has greater expressive power than relational algebra for [[transitive closure]] queries.

## [[Query Optimization]]

### [[Query Execution Plans]]
A **query execution plan** is a [[tree]] of [[relational operators]] with:
- **Leaf nodes**: Base relations or [[indexes]]
- **Internal nodes**: Relational algebra operations  
- **Edges**: Data flow between operations

### [[Cost Model]]
Query optimization uses [[cost functions]] $C: \text{Plans} \to \mathbb{R}^+$ considering:
- **I/O cost**: $C_{\text{IO}} = \text{pages\_read} \times c_{\text{read}} + \text{pages\_written} \times c_{\text{write}}$
- **CPU cost**: $C_{\text{CPU}} = \text{tuples\_processed} \times c_{\text{cpu}}$
- **Network cost**: $C_{\text{net}} = \text{bytes\_transmitted} \times c_{\text{network}}$

### [[Join Ordering]]
For $n$ relations, there are $\frac{(2n-2)!}{(n-1)!}$ possible [[join trees]]. [[Dynamic programming]] algorithms find optimal orderings:

**Optimal substructure**: 
$$\text{OPT}(S) = \min_{S_1 \cup S_2 = S, S_1 \cap S_2 = \emptyset} [C(S_1 \bowtie S_2) + \text{OPT}(S_1) + \text{OPT}(S_2)]$$

### [[Statistics]] and [[Cardinality Estimation]]
Query optimizers maintain [[histograms]] and [[statistics]]:
- **Cardinality**: $|R|$ (number of tuples)
- **Selectivity**: $\text{sel}(\phi) = \frac{|\sigma_{\phi}(R)|}{|R|}$
- **Join selectivity**: $\text{sel}(R \bowtie S) = \frac{|R \bowtie S|}{|R| \times |S|}$

## [[Transaction Theory]]

### [[ACID Properties]]
Transactions must satisfy:
- **[[Atomicity]]**: Either all operations complete or none do
- **[[Consistency]]**: Database remains in valid state
- **[[Isolation]]**: Concurrent transactions don't interfere  
- **[[Durability]]**: Committed changes persist despite failures

### [[Serializability Theory]]
A [[schedule]] $S$ of transactions is [[serializable]] if it is [[conflict-equivalent]] to some [[serial schedule]].

**Conflict operations**: $(r_i(X), w_j(X))$, $(w_i(X), r_j(X))$, $(w_i(X), w_j(X))$ where $i \neq j$.

**Conflict graph**: $G = (T, E)$ where $(T_i, T_j) \in E$ if operations of $T_i$ and $T_j$ conflict in $S$.

**Theorem**: $S$ is conflict-serializable iff its conflict graph is [[acyclic]].

### [[Concurrency Control]]

**[[Two-Phase Locking]] (2PL)**:
- **Growing phase**: Acquire locks, no releases
- **Shrinking phase**: Release locks, no acquisitions

**[[Timestamp Ordering]]**:
- $TS(T_i) < TS(T_j)$ implies $T_i$ appears before $T_j$ in serialization order
- **Thomas Write Rule**: Ignore outdated writes

**[[Multiversion Concurrency Control]] (MVCC)**:
- Maintain multiple versions of each data item
- Read operations see consistent snapshots
- Write operations create new versions

## [[Database Design Theory]]

### [[Entity-Relationship Model]]
[[ER diagrams]] model conceptual database structure:
- **[[Entity sets]]**: $E = \{e_1, e_2, \ldots, e_n\}$
- **[[Relationship sets]]**: $R \subseteq E_1 \times E_2 \times \cdots \times E_k$
- **[[Attributes]]**: Functions $A: E \to D$
- **[[Cardinality constraints]]**: $1:1$, $1:N$, $M:N$

### [[Schema Translation]]
ER-to-relational translation rules:
- **Entity**: Create relation with key attributes
- **Relationship**: Create relation with keys of participating entities
- **Weak entity**: Include identifying entity's key
- **ISA hierarchy**: [[Table-per-class]], [[table-per-hierarchy]], or [[table-per-concrete-class]]

### [[Schema Integration]]
Combining schemas requires resolving:
- **[[Naming conflicts]]**: Synonyms and homonyms
- **[[Structural conflicts]]**: Different representations
- **[[Semantic conflicts]]**: Different interpretations

## [[Integrity Constraints]]

### [[Key Constraints]]
- **[[Superkey]]**: $K$ such that no two tuples agree on all attributes in $K$
- **[[Candidate key]]**: Minimal superkey
- **[[Primary key]]**: Chosen candidate key
- **[[Foreign key]]**: References primary key of another relation

### [[Referential Integrity]]
For foreign key $FK$ referencing primary key $PK$:
$$\forall t \in R : t[FK] = \text{null} \lor \exists s \in S : s[PK] = t[FK]$$

### [[Semantic Integrity]]
Application-specific constraints:
- **[[Check constraints]]**: $\text{salary} > 0$
- **[[Assertions]]**: Complex cross-table constraints
- **[[Triggers]]**: Event-condition-action rules

## [[Dependency Theory]]

### [[Multivalued Dependencies]]
$X \twoheadrightarrow Y$ holds if for tuples $t_1, t_2$ agreeing on $X$:
$$\exists t_3, t_4 : t_3[X] = t_4[X] = t_1[X] = t_2[X] \land t_3[Y] = t_1[Y] \land t_3[Z] = t_2[Z]$$

where $Z = R - X - Y$.

### [[Join Dependencies]]
$\bowtie[R_1, R_2, \ldots, R_k]$ holds if:
$$r = \pi_{R_1}(r) \bowtie \pi_{R_2}(r) \bowtie \cdots \bowtie \pi_{R_k}(r)$$

### [[Inclusion Dependencies]]
$R[X] \subseteq S[Y]$ requires:
$$\forall t \in r : \exists s \in s : t[X] = s[Y]$$

## [[Complexity Theory]] in Databases

### [[Query Complexity]]
- **[[Data complexity]]**: Input size = database size (query fixed)
- **[[Expression complexity]]**: Input size = query size (database fixed)  
- **[[Combined complexity]]**: Input size = query + database size

### [[Computational Complexity]] Results
- **Selection, projection, union**: $O(n)$ 
- **Join**: $O(n^2)$ naive, $O(n \log n)$ with sorting
- **Transitive closure**: $O(n^3)$ (not in relational algebra)

### [[Conjunctive Queries]]
**Conjunctive query**: 
$$Q(x_1, \ldots, x_k) \leftarrow R_1(t_1), \ldots, R_m(t_m), \phi$$

where $\phi$ is a conjunction of equality atoms.

**[[Homomorphism theorem]]**: $Q_1 \subseteq Q_2$ iff there exists a [[homomorphism]] from $Q_2$ to $Q_1$.

## [[Distributed Databases]]

### [[Fragmentation]]
- **[[Horizontal fragmentation]]**: Partition tuples by selection predicates
- **[[Vertical fragmentation]]**: Partition attributes  
- **[[Mixed fragmentation]]**: Combination of both

### [[Distributed Query Processing]]
**Cost model**:
$$C_{\text{total}} = C_{\text{local}} + C_{\text{transmission}} + C_{\text{response}}$$

**[[Semijoin]] optimization**:
$$R \bowtie S = R \bowtie (S \ltimes R) = (R \ltimes S) \bowtie S$$

reduces data transmission.

### [[Distributed Transactions]]
**[[Two-Phase Commit]] (2PC)**:
1. **Prepare phase**: Coordinator asks participants to prepare
2. **Commit phase**: Coordinator decides commit/abort based on votes

**[[Byzantine Agreement]]** handles malicious failures in distributed consensus.

## [[Temporal Databases]]

### [[Temporal Data Models]]
- **[[Valid time]]**: When fact was true in real world
- **[[Transaction time]]**: When fact was stored in database
- **[[Bitemporal]]**: Both valid and transaction time

### [[Temporal Relational Algebra]]
Extensions include:
- **[[Temporal selection]]**: $\sigma_{\phi@t}(R)$
- **[[Temporal join]]**: $R \bowtie_{@} S$  
- **[[Temporal aggregation]]**: $\gamma_{A,@}^{f(B)}(R)$

## [[Deductive Databases]]

### [[Datalog]] Semantics
**[[Herbrand universe]]**: Set of all ground terms constructible from constants and function symbols.

**[[Herbrand interpretation]]**: Assignment of truth values to ground atoms.

**[[Model-theoretic semantics]]**: [[Least Herbrand model]] of program.

### [[Fixed-Point Semantics]]
For Datalog program $P$, the [[immediate consequence operator]] $T_P$:
$$T_P(I) = \{A : A \leftarrow B_1, \ldots, B_n \in P, B_1, \ldots, B_n \in I\}$$

**[[Least fixed point]]**: $\text{lfp}(T_P) = \bigcup_{i=0}^{\infty} T_P^i(\emptyset)$

## [[Physical Database Design]]

### [[Index Structures]]
- **[[B+ trees]]**: Balanced trees for range queries
- **[[Hash indexes]]**: Constant-time exact-match lookups
- **[[Bitmap indexes]]**: Efficient for low-cardinality attributes
- **[[R-trees]]**: Spatial data indexing

### [[Storage Models]]
- **[[Row stores]]**: Traditional tuple-oriented storage
- **[[Column stores]]**: Columnar storage for analytics
- **[[Hybrid storage]]**: Adaptive row/column organization

### [[Buffer Management]]
**[[Least Recently Used]] (LRU)**: Replace least recently accessed page.
**[[Clock algorithm]]**: Circular buffer with reference bits.
**[[Buffer pool]]**: $B$ pages, each page $P$ bytes, total capacity $B \times P$.

## Modern Extensions

### [[NoSQL]] Data Models
- **[[Document databases]]**: JSON/BSON document storage
- **[[Key-value stores]]**: Simple associative arrays
- **[[Graph databases]]**: Property graph model
- **[[Column families]]**: Wide-column stores

### [[NewSQL]]
Distributed SQL databases maintaining [[ACID]] properties:
- **[[Spanner]]**: Global consistency with [[TrueTime]]
- **[[CockroachDB]]**: Multi-region [[SERIALIZABLE]] isolation
- **[[FaunaDB]]**: [[Calvin]]-inspired deterministic scheduling

## Related Concepts

- [[Relational Algebra]]
- [[SQL]]
- [[Functional Dependencies]]
- [[Normalization]]
- [[Query Optimization]]
- [[Transaction Processing]]
- [[Concurrency Control]]
- [[ACID Properties]]
- [[CAP Theorem]]
- [[Consistency Models]]


---

preceding: [[pullback square]]  


following: [[codd's theorem]]

See also: [[distributed consensus]]


See also: [[power set]]