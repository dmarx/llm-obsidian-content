---
date: 1726443011.995119
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_7ab340f6-13d1-419f-b0fc-fef70cc7cb6d
- msg_aaa28a0d-dc60-46c1-a9c5-34d4415bd0fa
- msg_839ecfd0-2895-4065-9f41-54bc26c255a6
- colorclass/decision-making-processes
title: ensemble voting pattern
---

**ASSISTANT**

using Editor Agent...
Fact-checking report using Fact-Checker Agent...
Providing feedback using Critic Agent...

Final Report Output:
Research Output: The polar ice caps are melting at an accelerated rate due to global warming. This has led to rising sea levels and ecological impacts...
Draft Output: Climate change is having a devastating impact on the polar ice caps. The melting ice is contributing to rising sea levels and disrupting ecosystems...
Edited Report: The edited report highlights the key environmental challenges caused by melting polar ice caps, emphasizing the importance of global climate action...
Fact-Checked Report: The information in the report is factually accurate. No major corrections are needed.
Critic's Feedback: The report is clear and well-structured, but the introduction could be more engaging to capture the reader's attention. Consider adding an anecdote or a striking statistic.
```

### **Explanation**:

1. **Research Agent**: Gathers factual information about the topic.
2. **Writing Agent**: Produces a well-structured draft of the report based on the research.
3. **Editor Agent**: Refines the draft for clarity, style, and coherence.
4. **Fact-Checker Agent**: Ensures the accuracy of the information presented in the report.
5. **Critic Agent**: Provides feedback on the overall quality of the report, suggesting improvements or enhancements.

---

### **Step 6: Extending the Non-Trivial Agent Chain**

There are several ways to extend the **non-trivial agent chaining** pattern:
1. **Task-Specific Chains**: Create chains that are tailored to specific tasks, such as **software development** (e.g., design, coding, testing, reviewing) or **data science pipelines** (e.g., data collection, preprocessing, modeling, evaluation).
2. **Dynamic Chains**: Allow agents to adjust the chain based on the output they receive (e.g., if the fact-checker finds major errors, the chain could loop back to the research agent).
3. **Parallel Processing**: Some agents can work in parallel, such as the **Editor** and **Critic**, with the **Mediator Agent** resolving any conflicts at the end.

---

### **Learning Outcomes**:

1. **Sequential Agent Processing**: Students will learn how to implement agent chains where the output of one agent is the input for the next, ensuring complex workflows are handled smoothly.
   
2. **Non-Trivial Contributions**: Each agent in the chain adds significant value by transforming or refining the data, demonstrating the importance of **collaborative agent systems**.
   
3. **Workflow Coordination**: Students will gain experience designing workflows where multiple agents collaborate, ensuring the final output is polished and accurate.

4. **Handling Dependencies**: Chaining workflows often involve handling dependencies between agents (e.g., the fact-checker must wait for the editor to finish), teaching students how to manage these dependencies effectively.

---

### **Assignment Extension Ideas**:

1. **Error Handling**: Extend the system to allow agents to handle errors or discrepancies (e.g., if the fact-checker finds errors, the chain could return to the research agent for revisions).
   
2. **Adaptive Chaining**: Implement a more flexible chaining process where the agents can modify the order or number of steps dynamically based on intermediate results.
   
3. **Multi-Agent Collaboration**: Allow agents to communicate and collaborate during the chain, sharing insights and feedback before the chain completes.

---

### **Summary**:

In this assignment, students implement **non-trivial agent chaining**, where multiple agents work together sequentially to solve a complex task. Each agent in the chain contributes meaningfully by transforming or refining the output of the previous agent, resulting in a polished final product. This pattern helps students understand how to design systems where agents collaborate on multi-step processes, handle dependencies, and ensure high-quality results.


**USER**

ensemble voting pattern


**ASSISTANT**

### **Assignment: Implementing the Ensemble Voting Pattern**

In this assignment, students will learn to implement the **Ensemble Voting Pattern**, where multiple agents collaborate by independently generating responses and then voting on the best solution. This pattern is commonly used in ensemble learning in machine learning, but here it will be applied to multi-agent systems. The goal is to have agents with diverse expertise or perspectives provide different responses, and then use a **voting mechanism** to aggregate their opinions and choose the final result.

### **Objective**:
1. Teach students how to implement the **Ensemble Voting Pattern**, where multiple agents generate independent outputs, and the system votes on the best one.
2. Explore strategies for **combining diverse outputs** from different agents to arrive at a consensus.
3. Demonstrate the flexibility of multi-agent systems by showing how agents with different expertise can collaborate to improve decision-making.

---

### **What Is the Ensemble Voting Pattern?**

The **Ensemble Voting Pattern** involves multiple agents generating solutions to the same task independently. These solutions are then aggregated using a voting mechanism. The final result is either the most common output or a combination of the best elements from each agent’s solution. This pattern is useful in scenarios where:
1. **Diverse perspectives** or approaches are needed (e.g., creative tasks, code generation).
2. **Accuracy** is critical, and multiple agents help improve the likelihood of finding the correct solution.
3. **Reducing bias** is important, as each agent brings its own expertise to the table.

#### **Key Characteristics**:
- **Independent Agents**: Each agent provides a separate response without being influenced by the others.
- **Voting Mechanism**: A voting system aggregates the responses, determining the final output based on agent consensus or majority.
- **Diverse Expertise**: The agents can have different specializations, leading to varied perspectives or solutions.

#### **Use Cases**:
- **Creative Writing**: Multiple agents generate creative variations of a story, and the best version is chosen through voting.
- **Problem Solving**: Agents propose solutions to a technical problem, and the most widely agreed-upon solution is selected.
- **Code Review**: Agents review code independently, and the system votes on the most efficient or bug-free version.

---

### **Step 1: Setting Up the Agents**

We’ll begin by defining a set of agents, each of which will independently generate a solution to the same task. These agents will have different system prompts, encouraging them to approach the task from slightly different perspectives.

#### **Defining the Agents**:

```python
class Agent:
    def __init__(self, name, system_prompt_template):
        self.name = name
        self.system_prompt_template = system_prompt_template
        self.history = []  # Initialize conversation history
    
    def get_system_prompt(self):
        """
        Render the system prompt based on the agent's name and role.
        """
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
    
    def query_openai(self, user_input, max_tokens=100, temperature=0.7, top_p=1.0, **kwargs):
        """
        Send the conversation history to OpenAI and maintain the chat log.
        """
        self.history.append({"role": "user", "content": user_input})
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",  # Using a chat model that supports roles
            messages=self.history,
            max_tokens=max_tokens,
            temperature=temperature,
            top_p=top_p,
            **kwargs
        )
        assistant_reply = response.choices[0].message["content"]
        self.history.append({"role": "assistant", "content": assistant_reply})
        return assistant_reply
```

#### **Creating the Agents**:
Each agent will have a slightly different **system prompt**, guiding them to approach the problem with their own "style" or "perspective."

```python
# Define system prompts for each agent
agent_1_prompt = "You are an analytical assistant. Provide a logical and precise solution."
agent_2_prompt = "You are a creative assistant. Generate a creative and innovative solution."
agent_3_prompt = "You are a cautious assistant. Offer a safe, reliable, and well-tested solution."
agent_4_prompt = "You are a risk-taking assistant. Suggest a bold and unconventional solution."

# Create instances of the agents
agent_1 = Agent(name="AnalyticalAgent", system_prompt_template=agent_1_prompt)
agent_2 = Agent(name="CreativeAgent", system_prompt_template=agent_2_prompt)
agent_3 = Agent(name="CautiousAgent", system_prompt_template=agent_3_prompt)
agent_4 = Agent(name="RiskTakerAgent", system_prompt_template=agent_4_prompt)

# Store agents in a dictionary for easy access
agents = {
    "AnalyticalAgent": agent_1,
    "CreativeAgent": agent_2,
    "CautiousAgent": agent_3,
    "RiskTakerAgent": agent_4
}
```

---

### **Step 2: Implementing the Voting Mechanism**

The **voting mechanism** will aggregate the responses from the agents. We’ll use a simple majority voting scheme where the most common response is selected. If the agents provide unique responses, we may use some form of tie-breaking (e.g., selecting the first response or combining elements from multiple agents).

#### **Voting Manager Implementation**:

```python
from collections import Counter

class VotingManager:
    def __init__(self, agents):
        """
        Initialize the Voting Manager with a set of agents.
        
        Arguments:
        - agents: A dictionary mapping agent names to Agent objects.
        """
        self.agents = agents

    def collect_responses(self, user_input):
        """
        Collect responses from all agents for the given user input.
        
        Arguments:
        - user_input: The task or question provided by the user.
        
        Returns:
        - A list of responses generated by the agents.
        """
        responses = []
        for agent_name, agent in self.agents.items():
            print(f"Collecting response from {agent_name}...")
            response = agent.query_openai(user_input)
            responses.append(response)
        return responses

    def vote_on_best_response(self, responses):
        """
        Use a voting mechanism to determine the best response.
        
        Arguments:
        - responses: A list of responses generated by the agents.
        
        Returns:
        - The response selected by majority vote, or a tie-breaking response.
        """
        # Count how many times each response appears
        response_counter = Counter(responses)
        
        # Find the most common response
        most_common_responses = response_counter.most_common()
        
        if len(most_common_responses) == 1:
            # If there's a clear winner
            return most_common_responses[0][0]
        else:
            # If there's a tie or all responses are unique, select the first response (or combine responses)
            print("No clear winner, selecting first response as tie-breaker.")
            return most_common_responses[0][0]

    def ensemble_vote(self, user_input):
        """
        Collect responses from all agents and determine the best response via voting.
        
        Arguments:
        - user_input: The task or question provided by the user.
        
        Returns:
        - The final voted response.
        """
        # Step 1: Collect responses from all agents
        responses = self.collect_responses(user_input)
        
        # Step 2: Vote on the best response
        best_response = self.vote_on_best_response(responses)
        
        return best_response
```

---

### **Step 3: Implementing the CLI for Ensemble Voting**

We’ll now create a simple CLI interface where the user can input a task or question, and the **VotingManager** will collect and vote on the best response from the agents.

```python
def ensemble_voting_cli():
    print("Welcome to the Ensemble Voting System!\n")
    
    while True:
        user_input = input("Enter your task or question (type 'exit' to quit): ")
        
        if user_input.lower() == "exit":
            break
        
        # Use the voting manager to collect agent responses and vote on the best one
        final_response = voting_manager.ensemble_vote(user_input)
        
        print("\nFinal Voted Response:")
        print(f"{final_response}\n")

# Create an instance of the Voting Manager
voting_manager = VotingManager(agents=agents)

if __name__ == "__main__":
    ensemble_voting_cli()
```

---

### **Step 4: Running the Ensemble Voting System**

Now, when the user inputs a task or question, the **Voting Manager** will ask each agent to generate a solution and then determine the best response through voting.

#### **Example Interaction**:

```bash
Enter your task or question (type 'exit' to quit): How should we address the global water crisis?
Collecting response from AnalyticalAgent...
Collecting response from CreativeAgent...
Collecting response from CautiousAgent...
Collecting response from RiskTakerAgent...

Final Voted Response:
We should invest in large-scale desalination plants to convert seawater into drinkable water, while also focusing on efficient water management policies globally.
```

### **Explanation**:

1. **Analytical Agent**: Provides a logical, data-driven solution based on facts and analysis.
2. **Creative Agent**: Suggests an out-of-the-box solution, potentially more imaginative or unconventional.
3. **Cautious Agent**: Provides a safe and well-tested solution that minimizes risk.
4. **Risk-Taker Agent**: Proposes a bold, innovative solution that may involve higher risks but greater potential rewards.

The **Voting Manager** collects all responses and selects the most common or best solution via voting.

---

### **Step


---

preceding: [[assignment non-trivial agent chaining]]  


following: [[dynamic ensemble generation]]