---
date: 1726440730.952662
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_a335175b-0281-4f5d-baa6-0c623c8abf71
- msg_aaa20796-963b-4a58-aa41-339a5bea85e9
- msg_0698efea-4c59-42bb-b708-f1f657133364
- colorclass/edge-case
title: introduce classes through the context of a simple `agent` abstraction, where
  we assign each agent a system prompt and a name, and use  jinja to resolve each
  respective agent's system prompt
---

**ASSISTANT**

of how `**kwargs` works behind the scenes.


**USER**

introduce classes through the context of a simple `agent` abstraction, where we assign each agent a system prompt and a name, and use  jinja to resolve each respective agent's system prompt


**ASSISTANT**

Introducing **classes** through a simple **`Agent` abstraction** is a great way to help students understand the basics of object-oriented programming (OOP) while staying focused on practical use cases for LLMs. We can introduce the concept of classes by encapsulating behaviors and data (like the agent's name and system prompt) within an agent. Additionally, we can leverage **Jinja2** to dynamically resolve each agent's system prompt based on its attributes.

The key is to keep the explanation light, focusing on how classes help organize related data and behavior, and showing how they fit into the workflow the students have been building.

---

### **Ninth Assignment: Introducing Classes Through an Agent Abstraction**

### **Objective**:
1. Introduce **classes** as a way to group related data and behavior.
2. Create a simple `Agent` class that contains a **name** and a **system prompt**.
3. Use **Jinja2** to dynamically resolve the agent’s system prompt based on the agent’s attributes (like name).
4. Show how to instantiate multiple agents and interact with them.

---

### **Step 1: Introducing the `Agent` Class**

We start by defining a simple class called `Agent`. This class will encapsulate:
- The **name** of the agent.
- A **system prompt** that can be customized using Jinja2.
- A method to **render** the system prompt with agent-specific data (using Jinja2 templating).

Here’s how the initial class can be structured:

```python
from jinja2 import Template

# Define the Agent class
class Agent:
    def __init__(self, name, system_prompt_template):
        """
        Initialize the Agent with a name and a system prompt template.

        Arguments:
        - name: The name of the agent.
        - system_prompt_template: A Jinja2 template for the system prompt.
        """
        self.name = name
        self.system_prompt_template = system_prompt_template
    
    def get_system_prompt(self):
        """
        Render the system prompt using Jinja2 by substituting the agent's name.
        
        Returns:
        - The rendered system prompt.
        """
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
```

### **Explanation**:

1. **`__init__` Method**:
   - The `Agent` class’s constructor takes two parameters: `name` and `system_prompt_template`. The `name` is the agent’s identifier, and the `system_prompt_template` is a string that contains placeholders (e.g., `{{ name }}`) for the agent’s attributes.
   
2. **`get_system_prompt` Method**:
   - This method uses **Jinja2** to render the system prompt template, dynamically inserting the agent's `name` into the template.
   
3. **Jinja Template**:
   - The system prompt template uses placeholders like `{{ name }}` to insert values specific to each agent when the `get_system_prompt` method is called.

---

### **Step 2: Using the `Agent` Class**

Next, we’ll create multiple agents with different names and system prompts. Each agent will render their respective prompt using their own data.

Here’s a script that demonstrates how to create agents and display their system prompts:

```python
# Define different system prompt templates for each agent
agent1_template = "Hello, my name is {{ name }}. I specialize in helping with research tasks."
agent2_template = "Greetings! {{ name }} here. I'm an expert in creative writing assistance."

# Create two agents with their respective names and prompts
agent1 = Agent(name="Alice", system_prompt_template=agent1_template)
agent2 = Agent(name="Bob", system_prompt_template=agent2_template)

# Get and print the system prompt for each agent
print(f"Agent 1's system prompt:\n{agent1.get_system_prompt()}")
print(f"Agent 2's system prompt:\n{agent2.get_system_prompt()}")
```

**Expected Output**:
```bash
Agent 1's system prompt:
Hello, my name is Alice. I specialize in helping with research tasks.

Agent 2's system prompt:
Greetings! Bob here. I'm an expert in creative writing assistance.
```

### **Explanation**:

1. **Agent Instances**:
   - We create two instances of the `Agent` class (`agent1` and `agent2`), each with a different name and system prompt template. These agents will each have their own unique prompts.
   
2. **Dynamic Rendering**:
   - When we call `agent1.get_system_prompt()`, it uses the Jinja template system to substitute `{{ name }}` with `"Alice"`. Similarly, `agent2.get_system_prompt()` substitutes `{{ name }}` with `"Bob"`.
   
3. **Encapsulation**:
   - The `Agent` class encapsulates both the agent’s data (name and system prompt) and the behavior (rendering the system prompt). This is a key feature of classes—grouping related data and methods together in one logical unit.

---

### **Step 3: Expanding the Agent’s Functionality**

We can extend the `Agent` class by adding a method that sends the system prompt to the GPT API. This helps solidify the idea that the class encapsulates not only data but also the actions the agent can take.

Here’s how you can integrate the agent’s system prompt with the OpenAI API, leveraging the `query_gpt` function from previous lessons:

```python
import openai

# Extend the Agent class to interact with the OpenAI API
class Agent:
    def __init__(self, name, system_prompt_template):
        self.name = name
        self.system_prompt_template = system_prompt_template
    
    def get_system_prompt(self):
        template = Template(self.system_prompt_template)
        return template.render(name=self.name)
    
    def query_openai(self, max_tokens=50, temperature=0.7, top_p=1.0, **kwargs):
        """
        Send the agent's system prompt to the OpenAI API.
        
        Arguments:
        - max_tokens: Maximum number of tokens to generate.
        - temperature: Controls randomness in the output.
        - top_p: Controls diversity of word choices.
        - **kwargs: Additional options to pass to the OpenAI API.

        Returns:
        - The response from the OpenAI API.
        """
        system_prompt = self.get_system_prompt()

        # Make the API call with the agent's system prompt
        response = openai.Completion.create(
            model="text-davinci-003",
            prompt=system_prompt,
            max_tokens=max_tokens,
            temperature=temperature,
            top_p=top_p,
            **kwargs
        )
        return response
```

---

### **Using the Extended Agent Class**:

Now, we can use the `query_openai` method to send the agent’s system prompt to the OpenAI API. Here’s how we can instantiate agents and have them interact with the model:

```python
# Define different system prompt templates for each agent
agent1_template = "Hello, my name is {{ name }}. I specialize in helping with research tasks."
agent2_template = "Greetings! {{ name }} here. I'm an expert in creative writing assistance."

# Create two agents with their respective names and prompts
agent1 = Agent(name="Alice", system_prompt_template=agent1_template)
agent2 = Agent(name="Bob", system_prompt_template=agent2_template)

# Send each agent's system prompt to the GPT API
response1 = agent1.query_openai(max_tokens=100, temperature=0.8)
response2 = agent2.query_openai(max_tokens=100, temperature=0.8)

# Print out the response text for each agent
print(f"Agent 1's response:\n{response1.choices[0].text}")
print(f"Agent 2's response:\n{response2.choices[0].text}")
```

This shows how classes, especially with Jinja2, can help structure an agent system with unique prompts and behaviors. 

---

### **Key Concepts and Benefits of Classes**:

1. **Encapsulation**:
   - The `Agent` class groups together data (like `name` and `system_prompt_template`) and behavior (like `get_system_prompt()` and `query_openai()`), making the agent a self-contained unit.
   
2. **Reusability**:
   - Once the `Agent` class is defined, it’s easy to create multiple agents with different names and prompts without duplicating code.

3. **Dynamic Templating**:
   - By combining classes with **Jinja2**, we can dynamically generate system prompts based on each agent’s attributes, making it easy to manage different agents with unique prompts.

4. **Extensibility**:
   - The agent’s functionality can be extended without modifying existing code. For example, additional attributes or methods can be added to the class to support more complex behaviors.

---

### **Summary**:

This assignment introduces students to the concept of **classes** by creating an `Agent` abstraction. The class groups together the agent’s data (like `name`) and its behavior (like rendering system prompts or interacting with the OpenAI API). We use **Jinja2** to resolve the agent’s system prompts dynamically, based on the agent’s attributes. This approach shows the power of object-oriented programming and templating for managing complex, dynamic LLM interactions in a clean and scalable way.


---

preceding: [[next, introduce custom functions. start by pointing out it's a language feature the student has already been interacting with and proceed to modify the function signature and output of existing functi]]  


following: [[introduce `list.append` and demonstrate how to maintain and utilize per-agent interactionconversation histories]]