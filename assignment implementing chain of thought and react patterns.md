---
date: 1726443595.021547
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_aaa2b85f-ccdf-49ce-a5e9-7185846b28e9
- msg_795bd9ee-dc75-44e7-a005-1f203eff3929
- colorclass/decision-making-processes
title: assignment implementing chain of thought and react patterns
---

**USER**

chain of thought, ReAct, etc.


**ASSISTANT**

### **Assignment: Implementing Chain of Thought and ReAct Patterns**

In this assignment, students will explore advanced reasoning patterns in multi-agent systems, including **Chain of Thought (CoT)** and **ReAct (Reason + Act)**. These patterns are critical for building agents that not only provide direct answers but also engage in step-by-step reasoning, enabling them to **solve complex problems**, **explain their reasoning**, and **react dynamically** to evolving tasks.

### **Objective**:
1. Teach students how to implement **Chain of Thought (CoT)**, where agents break down complex tasks into reasoning steps, generating intermediate conclusions.
2. Introduce the **ReAct (Reason + Act)** pattern, which combines reasoning and real-time actions for more dynamic problem solving.
3. Show how combining these techniques can lead to more capable, adaptive agents that reason through problems, update their plans dynamically, and react to changing information.

---

### **What Is Chain of Thought (CoT) Reasoning?**

**Chain of Thought (CoT)** is a pattern where an agent solves a problem by **breaking it down into multiple steps**, explicitly reasoning through each step rather than providing a direct, "black-box" solution. This approach is especially useful for **complex tasks** that require multiple stages of reasoning, such as mathematical problems, logical puzzles, or strategic planning.

#### **Key Characteristics**:
- **Step-by-Step Reasoning**: The agent generates intermediate conclusions before arriving at the final answer.
- **Transparency**: The reasoning process is made explicit, helping the agent (and the user) understand how the solution was derived.
- **Incremental Progress**: Each reasoning step builds upon the previous one, allowing for easier debugging and refinement.

#### **Example Use Cases**:
- **Math Problem Solving**: The agent solves a complex equation by reasoning through each mathematical operation.
- **Logical Deduction**: The agent reasons through a sequence of steps to deduce a solution to a puzzle.
- **Project Planning**: The agent breaks down a task into a sequence of smaller steps and explains the rationale for each.

---

### **What Is the ReAct (Reason + Act) Pattern?**

**ReAct (Reason + Act)** is a pattern where the agent **combines reasoning with real-time actions** to solve problems. The agent thinks through a problem and then **acts dynamically** based on its reasoning, adjusting its approach in response to changes in the environment or new information.

#### **Key Characteristics**:
- **Reasoning and Action Integration**: The agent alternates between reasoning about a problem and taking actions based on that reasoning.
- **Adaptability**: The agent updates its actions in real-time based on evolving information or feedback.
- **Self-Correction**: The agent adjusts its reasoning and actions if it encounters obstacles or receives new data.

#### **Example Use Cases**:
- **Interactive Problem Solving**: The agent reasons about a task, performs actions, and revises its reasoning as it receives feedback from its actions.
- **Adaptive Strategies**: The agent updates its plan dynamically, adjusting to changing requirements or new obstacles in real-time.
- **Game Playing**: The agent reasons through strategies in a game and adjusts its play based on the opponent’s moves.

---

### **Step 1: Implementing Chain of Thought (CoT) Reasoning**

To implement **Chain of Thought (CoT)** reasoning, we’ll modify the agent to reason through a problem in multiple steps, generating intermediate reasoning outputs before arriving at the final solution.

#### **CoT Agent Implementation**:

```python
class CoTAgent(Agent):
    def __init__(self, name, system_prompt_template):
        """
        Initialize the Chain of Thought (CoT) agent with the standard system prompt.
        """
        super().__init__(name, system_prompt_template)
    
    def reason_step_by_step(self, user_input):
        """
        Solve the problem using step-by-step reasoning.
        
        Arguments:
        - user_input: The problem provided by the user.
        
        Returns:
        - The final answer after reasoning through multiple steps.
        """
        prompt = f"Let's solve this problem step-by-step: {user_input}"
        response = self.query_openai(prompt)
        
        return response
```

### **Example Chain of Thought Task**:
Let’s say the user asks the agent: **"What is 345 + 678?"**. Instead of directly outputting the answer, the **CoTAgent** will explain its reasoning:

```bash
You: What is 345 + 678?
CoTAgent: Let's solve this problem step-by-step:
1. First, we add the digits in the ones place: 5 + 8 = 13, so we write 3 and carry over 1.
2. Next, we add the digits in the tens place: 4 + 7 = 11, plus the carry-over 1 makes it 12, so we write 2 and carry over 1.
3. Finally, we add the digits in the hundreds place: 3 + 6 = 9, plus the carry-over 1 makes it 10, so the final result is 1023.
Answer: 345 + 678 = 1023.
```

---

### **Step 2: Implementing the ReAct (Reason + Act) Pattern**

The **ReAct Agent** alternates between reasoning and taking actions. It dynamically adjusts its plan based on the outcomes of its actions, updating its reasoning in response to real-time feedback.

#### **ReAct Agent Implementation**:

```python
class ReActAgent(Agent):
    def __init__(self, name, system_prompt_template):
        """
        Initialize the ReAct (Reason + Act) agent.
        """
        super().__init__(name, system_prompt_template)
    
    def reason_and_act(self, user_input):
        """
        Perform reasoning and then take actions based on that reasoning.
        
        Arguments:
        - user_input: The task provided by the user.
        
        Returns:
        - The final output after reasoning and taking actions.
        """
        reasoning = f"Let's reason through this task first: {user_input}"
        print("Reasoning about the task...")
        reasoning_output = self.query_openai(reasoning)
        
        print("Taking action based on reasoning...")
        action = f"Based on the reasoning: {reasoning_output}, let's now take the following action."
        action_output = self.query_openai(action)
        
        return reasoning_output, action_output
```

### **Example ReAct Task**:
Let’s say the user asks the agent to **"Find a restaurant and make a reservation."** The **ReActAgent** will reason about the problem first, then dynamically act based on its reasoning:

```bash
You: Find a restaurant and make a reservation.
ReActAgent: Let's reason through this task first:
- We need to choose a restaurant based on preferences such as cuisine, location, and availability.
- Next, we need to check whether the restaurant accepts reservations online or via phone.
- After that, we will attempt to make the reservation.

Taking action based on reasoning...
I found a restaurant that matches your preferences. Now attempting to make a reservation.
```

---

### **Step 3: Combining Chain of Thought and ReAct Patterns**

By combining **Chain of Thought** reasoning with **ReAct** actions, we can build agents that first break down a problem into reasoning steps and then take dynamic actions based on that reasoning.

#### **CoT + ReAct Agent Implementation**:

```python
class CoTReActAgent(Agent):
    def __init__(self, name, system_prompt_template):
        """
        Initialize the CoT + ReAct agent.
        """
        super().__init__(name, system_prompt_template)
    
    def reason_and_act_dynamically(self, user_input):
        """
        Perform step-by-step reasoning and then take dynamic actions based on that reasoning.
        
        Arguments:
        - user_input: The task provided by the user.
        
        Returns:
        - The final output after reasoning and acting dynamically.
        """
        print("Breaking down the problem step-by-step...")
        reasoning_steps = f"Let's solve this problem step-by-step: {user_input}"
        reasoning_output = self.query_openai(reasoning_steps)
        
        print("Taking action based on the reasoning...")
        action_steps = f"Based on our reasoning: {reasoning_output}, let's now take the following action."
        action_output = self.query_openai(action_steps)
        
        return reasoning_output, action_output
```

### **Example CoT + ReAct Task**:
Let’s say the user asks the agent to **"Plan a trip and book a flight."** The **CoTReActAgent** will first reason through the steps of planning a trip, then take action (e.g., booking a flight) based on its reasoning.

```bash
You: Plan a trip and book a flight.
CoTReActAgent: Breaking down the problem step-by-step:
1. First, we need to decide on the destination.
2. Next, we need to determine the travel dates and preferences.
3. Then, we will search for available flights based on your preferences.

Taking action based on the reasoning...
I found several flights matching your preferences. Now attempting to book the flight.
```

---

### **Step 4: Implementing the CLI for CoT and ReAct Agents**

We will now implement a simple CLI that allows the user to choose between a **Chain of Thought (CoT) Agent**, a **ReAct Agent**, or a **CoT + ReAct Agent** for dynamic reasoning and action.

```python
def reasoning_cli():
    print("Welcome to the Reasoning and Action System!\n")
    
    while True:
        print("Choose an agent:")
        print("1. Chain of Thought (CoT) Agent")
        print("2. ReAct (Reason + Act


---

preceding: [[that's definitely content we should include as well, but i actually meant in this context]]  


following: [[rag]]

See also: [[strategic planning]]