---
date: 1727917273.714176
tags:
- autogenerated
- source__oai
- conversation_id__66fdeb95-c32c-8008-9a23-d10da96b1985
- msg_3dd27650-6afc-4e75-bca4-fc532967d8c4
- msg_518f623e-e34b-450f-8c95-0dde92c21bdc
- colorclass/edge-case
title: solid principles
---

**USER**

SOLID principles


**ASSISTANT**

The **SOLID principles** are a set of five guidelines in object-oriented design intended to create software that is easy to maintain, extend, and scale. These principles help reduce software complexity, increase reusability, and facilitate a clear separation of concerns, resulting in more robust and adaptable systems.

## SOLID: An Overview

The acronym **SOLID** stands for:
1. **S** - **Single Responsibility Principle (SRP)**
2. **O** - **Open/Closed Principle (OCP)**
3. **L** - **Liskov Substitution Principle (LSP)**
4. **I** - **Interface Segregation Principle (ISP)**
5. **D** - **Dependency Inversion Principle (DIP)**

Each of these principles addresses a particular aspect of software design and contributes to a more modular, flexible, and maintainable codebase.

---

## 1. Single Responsibility Principle (SRP)

**A class should have one, and only one, reason to change.**

This principle states that a class should have a single responsibility, meaning it should encapsulate only one piece of functionality or behavior. Having multiple responsibilities in a class leads to high coupling and low cohesion, making the code harder to understand, maintain, and test.

### Example:
**Violation of SRP:**
A `User` class that handles user data, validation, and database operations:
```python
class User:
    def __init__(self, name, email):
        self.name = name
        self.email = email
    
    def validate(self):
        # Validate user input
        if "@" not in self.email:
            raise ValueError("Invalid email")
    
    def save_to_db(self):
        # Code to save user to database
        pass
```
**Applying SRP:** Break it into three separate classes:
- `User`: Holds user data.
- `UserValidator`: Handles validation logic.
- `UserRepository`: Manages database operations.

---

## 2. Open/Closed Principle (OCP)

**Software entities (classes, modules, functions) should be open for extension but closed for modification.**

This principle encourages developers to write code that can be extended without modifying existing source code. To achieve this, abstraction (interfaces, abstract classes) is used so that new functionality can be added via new classes rather than changing existing ones.

### Example:
**Violation of OCP:**
```python
class PaymentProcessor:
    def process(self, payment_type):
        if payment_type == "credit":
            self.process_credit()
        elif payment_type == "paypal":
            self.process_paypal()
```
**Applying OCP:** Introduce an abstraction for different payment methods:
```python
class PaymentProcessor(ABC):
    @abstractmethod
    def process(self):
        pass

class CreditPayment(PaymentProcessor):
    def process(self):
        # Process credit payment

class PaypalPayment(PaymentProcessor):
    def process(self):
        # Process PayPal payment
```
Now, new payment types can be added by creating new subclasses of `PaymentProcessor`.

---

## 3. Liskov Substitution Principle (LSP)

**Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program.**

This principle suggests that a subclass should not alter the expected behavior of the superclass. Any derived class should be able to replace its base class and function correctly within the system. Violations of LSP often indicate that a subclass has an incompatible implementation or breaks the expected behavior of the base class.

### Example:
**Violation of LSP:**
```python
class Bird:
    def fly(self):
        pass

class Penguin(Bird):
    def fly(self):
        raise NotImplementedError("Penguins can't fly")
```
**Applying LSP:** Refactor to separate flying and non-flying birds:
```python
class Bird(ABC):
    pass

class FlyingBird(Bird):
    @abstractmethod
    def fly(self):
        pass

class Sparrow(FlyingBird):
    def fly(self):
        # Sparrow flying logic

class Penguin(Bird):
    pass
```

---

## 4. Interface Segregation Principle (ISP)

**A class should not be forced to implement interfaces it does not use.**

This principle promotes creating smaller, more specific interfaces rather than large, monolithic ones. It ensures that classes implement only the methods that are relevant to them, reducing unnecessary dependencies and promoting flexibility.

### Example:
**Violation of ISP:**
```python
class WorkerInterface:
    def work(self):
        pass

    def eat(self):
        pass

class Robot(WorkerInterface):
    def work(self):
        # Robot work logic

    def eat(self):
        # Robots don't eat, so this is irrelevant
```
**Applying ISP:** Break down the interface into smaller, more specific ones:
```python
class Workable:
    @abstractmethod
    def work(self):
        pass

class Eatable:
    @abstractmethod
    def eat(self):
        pass

class Human(Workable, Eatable):
    def work(self):
        # Human work logic

    def eat(self):
        # Human eating logic

class Robot(Workable):
    def work(self):
        # Robot work logic
```

---

## 5. Dependency Inversion Principle (DIP)

**High-level modules should not depend on low-level modules. Both should depend on abstractions.**  
**Abstractions should not depend on details. Details should depend on abstractions.**

DIP suggests that to decouple high-level logic from low-level implementations, they should both rely on abstractions (e.g., interfaces, abstract classes). This decoupling allows for more flexible and easily modifiable software systems.

### Example:
**Violation of DIP:**
```python
class EmailService:
    def send_email(self, message):
        # Send email

class UserNotification:
    def __init__(self):
        self.email_service = EmailService()

    def notify(self, message):
        self.email_service.send_email(message)
```
**Applying DIP:** Use abstraction:
```python
class NotificationService(ABC):
    @abstractmethod
    def send(self, message):
        pass

class EmailService(NotificationService):
    def send(self, message):
        # Send email

class UserNotification:
    def __init__(self, notification_service: NotificationService):
        self.notification_service = notification_service

    def notify(self, message):
        self.notification_service.send(message)
```
Now, `UserNotification` depends on the `NotificationService` abstraction, making it easy to swap out the concrete implementation.

---

## Summary of SOLID

The **SOLID** principles work together to promote:
- **SRP:** Breaking classes into single responsibilities for clarity and ease of modification.
- **OCP:** Designing classes that can be extended without modifying existing code.
- **LSP:** Ensuring derived classes conform to the behavior of their base classes.
- **ISP:** Avoiding large, general-purpose interfaces, promoting use-case-specific interfaces.
- **DIP:** Decoupling high-level modules from low-level modules through the use of abstractions.

By applying these principles, software design becomes more adaptable, testable, maintainable, and scalable. Each principle addresses a common source of complexity and potential problems in software projects, making them invaluable guidelines for creating high-quality object-oriented software.


---

preceding: [[dependency inversion principle]]

See also: [[separation of concerns]]