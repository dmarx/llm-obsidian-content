---
date: 1718260837.919874
tags:
- autogenerated
- source__oai
- conversation_id__937e6f6e-8555-450c-a3a1-95ea43089b40
- msg_aaa203e4-561f-48bc-9cf1-b34bc4d969d4
- msg_370cb833-77c9-4a96-bdf5-f11117ac17d6
- colorclass/decision-making-processes
title: recursion
---

**USER**

recursion


**ASSISTANT**

Recursion is a fundamental concept in mathematics and computer science where a function calls itself in its definition. This concept is widely used to solve problems that can be broken down into smaller, similar sub-problems.

## Mathematical Definition

In a mathematical context, recursion is often defined using recurrence relations. A simple example is the definition of the factorial function:

$$
n! =
\begin{cases}
1 & \text{if } n = 0 \\
n \cdot (n-1)! & \text{if } n > 0
\end{cases}
$$

Here, the factorial of a number $n$ is defined in terms of the factorial of $n-1$, demonstrating the recursive nature of the function.

## Formal Definition

A function $f$ is said to be recursive if it can be defined by:

$$
f(x) = 
\begin{cases}
g(x) & \text{if } x \text{ is a base case} \\
h(x, f(y_1), f(y_2), \ldots, f(y_k)) & \text{if } x \text{ is a recursive case}
\end{cases}
$$

where $g$ is a function that handles the base case(s), and $h$ is a function that incorporates recursive calls to $f$ on smaller instances $y_1, y_2, \ldots, y_k$ of the original problem $x$.

## Example: Fibonacci Sequence

A classic example of recursion in mathematics is the Fibonacci sequence, defined as:

$$
F(n) =
\begin{cases}
0 & \text{if } n = 0 \\
1 & \text{if } n = 1 \\
F(n-1) + F(n-2) & \text{if } n > 1
\end{cases}
$$

In this example, each term of the sequence is defined in terms of the two preceding terms, illustrating a recursive structure.

## Recursion in Computer Science

In computer science, recursion is a method where the solution to a problem depends on solutions to smaller instances of the same problem. Recursive algorithms often have the following structure:

1. **Base Case**: The simplest instance of the problem, which can be solved directly.
2. **Recursive Case**: The problem is divided into smaller instances, each of which is solved by applying the same algorithm.

### Example: Recursive Implementation of Factorial

Here is a recursive implementation of the factorial function in a programming language like Python:

```python
def factorial(n):
    if n == 0:
        return 1
    else:
        return n * factorial(n - 1)
```

### Example: Recursive Implementation of Fibonacci Sequence

Similarly, the Fibonacci sequence can be implemented recursively:

```python
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)
```

## Recursion vs. Iteration

While recursion can be a powerful tool, it is often compared to iteration. Iterative solutions use loops to repeat a block of code, while recursive solutions call the function itself. For some problems, recursion can be more intuitive and easier to implement, but it may also lead to higher memory usage due to the function call stack. Iterative solutions are generally more memory efficient.

### Tail Recursion

A special case of recursion is tail recursion, where the recursive call is the last operation in the function. Tail-recursive functions can be optimized by the compiler to avoid increasing the call stack, leading to more efficient execution. For example, the factorial function can be written in a tail-recursive manner:

```python
def factorial_tail(n, accumulator=1):
    if n == 0:
        return accumulator
    else:
        return factorial_tail(n - 1, n * accumulator)
```

## Applications of Recursion

Recursion is widely used in various fields such as:

- **[[Algorithms]]**: Many algorithms, especially divide-and-conquer algorithms like quicksort and mergesort, are naturally recursive.
- **[[Data Structures]]**: Recursive structures like trees and graphs are often traversed using recursive algorithms.
- **[[Mathematical Proofs]]**: Inductive proofs often rely on a recursive structure.
- **[[Dynamic Programming]]**: Problems are broken down into overlapping subproblems, which are solved recursively and stored to avoid redundant calculations.

Recursion is a powerful tool that, when used appropriately, can simplify the implementation of complex algorithms and solve problems elegantly.


---


following: [[fibonacci sequence]]

See also: [[recursion can always be implemented as a loop]]