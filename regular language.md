---
date: 1717503192.945894
tags:
- autogenerated
- source__oai
- conversation_id__35a07ad4-9b42-4cf2-8a4c-569d024e5d9f
- msg_60222a81-e04d-4d19-ae9f-a53bed27c6c4
- msg_a8504689-b779-4eac-acc3-49b9bb592581
- colorclass/emotional-regulation
title: regular language
---

**USER**

Regular language


**ASSISTANT**

A **regular language** is a type of formal language that can be defined by a regular expression, recognized by a finite automaton, or generated by a regular grammar. Regular languages are the simplest class in the Chomsky hierarchy and have numerous applications in computer science, particularly in text processing, lexical analysis, and pattern matching.

### Formal Definitions

#### Regular Expressions

A **regular expression** is a sequence of characters that defines a search pattern. Regular expressions can be constructed using the following operations:

1. **Union (or alternation)**: If $r_1$ and $r_2$ are regular expressions, then $(r_1 \mid r_2)$ is also a regular expression representing the union of the languages denoted by $r_1$ and $r_2$.
2. **Concatenation**: If $r_1$ and $r_2$ are regular expressions, then $(r_1 r_2)$ is also a regular expression representing the concatenation of the languages denoted by $r_1$ and $r_2$.
3. **Kleene star**: If $r$ is a regular expression, then $r^*$ is also a regular expression representing the Kleene closure (zero or more repetitions) of the language denoted by $r$.

#### Finite Automaton

A **finite automaton** is an abstract machine used to recognize regular languages. There are two main types of finite automata:

1. **Deterministic Finite Automaton (DFA)**: A DFA has exactly one transition for each symbol in the alphabet from each state.
2. **Nondeterministic Finite Automaton (NFA)**: An NFA can have multiple transitions for each symbol in the alphabet from each state, including transitions to multiple states or epsilon (Îµ) transitions that consume no input symbol.

##### DFA Formal Definition

A DFA is defined by the 5-tuple $M = (Q, \Sigma, \delta, q_0, F)$ where:

- $Q$: A finite set of states.
- $\Sigma$: A finite set of input symbols (alphabet).
- $\delta$: The transition function, $\delta: Q \times \Sigma \rightarrow Q$.
- $q_0$: The start state, $q_0 \in Q$.
- $F$: The set of accept states, $F \subseteq Q$.

##### NFA Formal Definition

An NFA is defined by the 5-tuple $M = (Q, \Sigma, \delta, q_0, F)$ where:

- $Q$: A finite set of states.
- $\Sigma$: A finite set of input symbols (alphabet).
- $\delta$: The transition function, $\delta: Q \times (\Sigma \cup \{\varepsilon\}) \rightarrow 2^Q$.
- $q_0$: The start state, $q_0 \in Q$.
- $F$: The set of accept states, $F \subseteq Q$.

### Regular Grammars

A **regular grammar** is a formal grammar that generates a regular language. It has production rules of the following forms:

- **Right-linear grammar**: All production rules are of the form $A \rightarrow aB$ or $A \rightarrow a$, where $A$ and $B$ are non-terminal symbols, and $a$ is a terminal symbol.
- **Left-linear grammar**: All production rules are of the form $A \rightarrow Ba$ or $A \rightarrow a$.

### Properties of Regular Languages

1. **Closure Properties**: Regular languages are closed under several operations, including:
   - Union
   - Intersection
   - Complement
   - Concatenation
   - Kleene star
   - Reversal

2. **Decidability**: There are efficient algorithms to decide whether:
   - A given string belongs to a regular language.
   - A given regular language is empty.
   - Two regular languages are equivalent.
   - A regular language is a subset of another regular language.

3. **Pumping Lemma**: The pumping lemma provides a property that all regular languages must satisfy. It is often used to prove that a language is not regular.

### Examples of Regular Languages

1. **Simple Strings**: 
   - $\{a, b, ab, ba\}$ (finite set of strings)
   - $\{a^n \mid n \geq 0\}$ (strings of zero or more a's)
2. **Patterns**:
   - Binary strings with an even number of zeros: $\{w \in \{0,1\}^* \mid \text{number of 0's in } w \text{ is even}\}$
   - Strings that do not contain the substring "101": $\{w \in \{0,1\}^* \mid w \text{ does not contain } 101\}$

### Example of a DFA

Consider the language $L = \{w \in \{a, b\}^* \mid w \text{ contains an even number of } a\text{s}\}$.

1. **States**: $Q = \{q_0, q_1\}$ where $q_0$ is the start state.
2. **Alphabet**: $\Sigma = \{a, b\}$
3. **Transition Function**: Defined as:
   - $\delta(q_0, a) = q_1$
   - $\delta(q_0, b) = q_0$
   - $\delta(q_1, a) = q_0$
   - $\delta(q_1, b) = q_1$
4. **Start State**: $q_0$
5. **Accept States**: $F = \{q_0\}$

### Regular Expression Example

For the same language $L = \{w \in \{a, b\}^* \mid w \text{ contains an even number of } a\text{s}\}$, the regular expression can be given by:

$$
(a b^* a b^*)^*
$$

### Further Reading

- [[Automata Theory]]
- [[Context-Free Grammar]]
- [[Finite Automaton]]
- [[Deterministic Finite Automaton]]
- [[Nondeterministic Finite Automaton]]
- [[Regular Expression]]
- [[Pumping Lemma]]

Regular languages are fundamental in the theory of computation, forming the basis for understanding more complex classes of languages and automata. Their simplicity and well-defined properties make them a crucial tool in various applications in computer science.


---

preceding: [[pumping lemma]]

See also: [[automata theory]]


See also: [[myhill-nerode theorem]]


See also: [[deterministic finite automata]]


See also: [[nerode equivalence]]