---
date: 1726441878.66477
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_81fe07b2-5a2e-4ab2-bb3e-603de17b43a3
- msg_aaa23e5d-fb6f-4810-9837-827c5cee3091
- msg_a655a3c1-9f06-48cf-9d03-41775b6e30e4
- colorclass/emotional-regulation
title: what other agentic programming patterns should we discuss
---

**ASSISTANT**

The capital of France is Paris.
FactChecker: I have fact-checked the response. It is correct that Paris is the capital of France.

Enter your choice (1 or 2): 1
You: Can you explain quantum mechanics?
PrimaryAgent: Quantum mechanics is a fundamental theory in physics that describes physical properties on the atomic and subatomic scale.
```

### **Explanation**:

1. **Primary Agent**: Provides an initial response based on the user’s input.
2. **Fact-Checker Agent**: Reviews the primary agent’s response and verifies its accuracy, providing corrections or confirming the answer.

---

### **Learning Outcomes**:

1. **Inter-Agent Collaboration**:
   - Students learn how to structure agents to collaborate, passing information between them and using one agent to verify or enhance the response of another.

2. **Fact-Checker Pattern**:
   - The **Fact-Checker Agent** pattern demonstrates how one agent can be specialized to verify the correctness or quality of another agent’s output.

3. **Separation of Responsibilities**:
   - The fact-checker and primary agent have distinct roles, enforcing good design principles by separating tasks between agents. This ensures modular, testable, and extensible code.

4. **Chaining Agent Behavior**:
   - By allowing agents to interact, students see how agent behaviors can be chained to create more sophisticated, multi-step processing pipelines.

---

### **Assignment Extension (Optional)**:

1. **Expert Agent Collaboration**:
   - Add a **domain-specific expert agent** (e.g., a medical expert) who collaborates with the primary agent to provide expertise in certain fields, followed by a fact-checker to verify medical claims.

2. **Multiple Fact-Checkers**:
   - Extend the pattern by introducing multiple fact-checkers who specialize in different domains (e.g., science fact-checker, historical fact-checker).

---

### **Summary**:

In this assignment, students learn how to implement **inter-agent collaboration** through the **Fact-Checker Agent** pattern. By creating agents that work together—one providing information and the other verifying it—students see how collaborative agents can produce more accurate and reliable results. This assignment reinforces concepts like agent specialization, role separation, and chaining behaviors, making the chatbot more robust and contextually aware.


**USER**

what other agentic programming patterns should we discuss?


**ASSISTANT**

In addition to the **Fact-Checker Agent** pattern, there are several other **agentic programming patterns** that are useful in the context of building systems where multiple agents collaborate or have specialized roles. These patterns can help design systems that are modular, adaptable, and capable of tackling complex tasks by distributing responsibilities across different agents.

Here’s a list of other **agentic programming patterns** that would be valuable to discuss:

---

### 1. **Delegator Agent Pattern**

#### **Description**:
The **Delegator Agent** acts as an intermediary that distributes tasks to other specialized agents. It is responsible for receiving a task from the user, deciding which agent(s) should handle each subtask, and then gathering the results.

#### **Use Cases**:
- **Task Distribution**: Useful in systems where tasks can be broken down into smaller subtasks (e.g., a software development assistant breaking down a project into coding, documentation, and testing tasks).
- **Multi-agent Coordination**: The delegator assigns specific roles to agents (e.g., research, writing, and verification) and gathers their contributions into a final result.

#### **Implementation**:
- The **Delegator Agent** receives a high-level task and splits it into subtasks.
- It delegates these subtasks to specialized agents based on their expertise.
- Finally, the delegator collects the responses from each agent and assembles them into a cohesive output.

#### **Example**:
```python
class DelegatorAgent:
    def __init__(self, agents):
        self.agents = agents  # A dictionary of specialized agents
    
    def delegate(self, user_task):
        """
        Delegate tasks to different agents based on their expertise.
        """
        if "write" in user_task:
            return self.agents["Writer"].query_openai(user_task)
        elif "research" in user_task:
            return self.agents["Researcher"].query_openai(user_task)
        # Other delegation logic based on the task
```

---

### 2. **Mediator Agent Pattern**

#### **Description**:
The **Mediator Agent** coordinates the interaction between two or more agents who may not communicate directly. It resolves conflicts, ensures proper coordination, and facilitates communication between agents working on different aspects of a problem.

#### **Use Cases**:
- **Conflict Resolution**: When agents provide conflicting or contradictory outputs (e.g., two experts disagree), the mediator agent determines which one should be prioritized or requests clarifications from both.
- **Agent Collaboration**: Mediating collaboration between multiple agents working on different parts of a large problem, ensuring that they communicate efficiently.

#### **Implementation**:
- The **Mediator Agent** manages communication between agents, passing results between them when needed.
- It resolves discrepancies in agent outputs and ensures agents collaborate smoothly by providing context or instructions.

#### **Example**:
- An expert agent provides an initial opinion, and a second expert agent contradicts it. The mediator requests additional information from both agents to reach a consensus or prioritize one agent’s response over the other.

---

### 3. **Orchestrator Agent Pattern**

#### **Description**:
The **Orchestrator Agent** coordinates a complex, multi-step workflow by arranging the sequence of actions taken by other agents. This pattern is focused on managing workflows where agents must perform their tasks in a specific order, with each step depending on the results of previous steps.

#### **Use Cases**:
- **Complex workflows**: Managing multi-step tasks, such as research, writing, review, and fact-checking, where agents need to collaborate in a specific sequence.
- **Workflow automation**: Useful in automating complex, multi-agent workflows that involve dependency chains (e.g., a project manager agent overseeing a sequence of tasks like planning, development, and testing).

#### **Implementation**:
- The **Orchestrator Agent** is responsible for ensuring that tasks are executed in the correct order, triggering each agent's task when appropriate.
- It might wait for the results of one agent before triggering the next agent in the workflow.

#### **Example**:
- The orchestrator manages a writing project. The **Research Agent** collects information, then passes it to the **Writing Agent**. Once the writing is complete, the **Editor Agent** reviews and revises the draft.

---

### 4. **Critic Agent Pattern**

#### **Description**:
The **Critic Agent** provides critical feedback on a solution or response generated by another agent. Instead of simply verifying facts (like the Fact-Checker), the Critic Agent evaluates quality, coherence, or style, suggesting improvements or offering an alternative perspective.

#### **Use Cases**:
- **Creative Work**: When dealing with creative writing, code generation, or artwork, the critic agent provides feedback on how to improve or refine the work.
- **Quality Control**: Useful in scenarios where the quality of output is subjective (e.g., assessing the clarity or tone of a piece of writing).

#### **Implementation**:
- The **Critic Agent** receives the output of another agent and provides feedback based on predefined criteria (e.g., clarity, tone, adherence to the user’s requirements).
- The critic might suggest changes or directly revise the output.

#### **Example**:
- A **Writing Agent** generates a creative story, and the **Critic Agent** reviews the story, suggesting that certain sections could be more engaging or that the tone should be adjusted.

---

### 5. **Contextual Enhancer Agent Pattern**

#### **Description**:
The **Contextual Enhancer Agent** enriches an agent's response by providing additional context or supplementary information. It augments the output with relevant data, examples, or clarifications, making the response more comprehensive.

#### **Use Cases**:
- **Augmented Responses**: Adding background information, related concepts, or examples to a core response. For example, when an agent answers a question about a scientific concept, the enhancer agent provides historical context or examples.
- **Teaching or Learning Environments**: When an agent provides an answer, the enhancer explains it in more depth, offering additional learning resources or analogies.

#### **Implementation**:
- The **Enhancer Agent** takes the initial response and appends additional context, background information, or related examples.
- The enhanced response is sent back to the user, giving them a richer, more informed answer.

#### **Example**:
- A **Math Tutor Agent** provides an answer to a question about calculus. The **Enhancer Agent** adds examples, visual explanations, and links to relevant tutorials or exercises.

---

### 6. **Summarizer Agent Pattern**

#### **Description**:
The **Summarizer Agent** condenses the output of one or more agents into a concise form. It helps manage information overload by providing brief but meaningful summaries of responses, reports, or conversations.

#### **Use Cases**:
- **Information Overload**: Useful when dealing with large amounts of data or long responses. The summarizer condenses key points and provides concise information.
- **Task Reports**: Summarizing the output of multiple agents working on different parts of a problem (e.g., summarizing research, writing, and fact-checking agents' outputs into a single report).

#### **Implementation**:
- The **Summarizer Agent** takes the outputs of one or more agents and generates a concise summary that captures the key points.
- It might offer summaries of long conversations or condense large documents into brief overviews.

#### **Example**:
- After a long discussion involving multiple agents (research, writing, fact-checking), the summarizer condenses the key points into a brief summary for the user.

---

### 7. **Strategist Agent Pattern**

#### **Description**:
The **Strategist Agent** is responsible for planning and decision-making. It helps formulate strategies based on goals and constraints, advising other agents on how to proceed. This agent could be used for long-term planning, setting priorities, or optimizing workflows.

#### **Use Cases**:
- **Project Planning**: Creating a strategic plan for accomplishing a project by setting goals, delegating tasks, and managing priorities.
- **Decision-Making**: When agents are unsure about the next step, the strategist advises them on the optimal course of action based on the overall objectives.

#### **Implementation**:
- The **Strategist Agent** analyzes the task, considers the available agents' expertise, and formulates a step-by-step plan for achieving the desired outcome.
- It provides guidance on which agent should perform specific tasks and in what order.

#### **Example**:
- In a software project, the **Strategist Agent** creates a roadmap, advising the developer agent on which features to implement first and when to involve the testing agent.

---

### 8. **Memory Agent Pattern**

#### **Description**:
The **Memory Agent** stores and retrieves information over the course of interactions. It is responsible for maintaining a persistent memory of previous conversations, decisions, and results, allowing the system to build long-term context and improve interactions over time.

#### **Use Cases**:
- **Long-term Conversations**: The Memory Agent can recall information from previous sessions, making it useful for long-term tasks like tutoring, coaching, or collaborative projects.
- **Persistent State**: Useful in systems that need to maintain a persistent state across multiple interactions, remembering user preferences, past answers, or context.

#### **Implementation**:
- The **Memory Agent** keeps a record of important facts, decisions, or outcomes from each conversation and provides this context when queried in future interactions.
- It can integrate with other agents by providing them with context from previous tasks.

#### **Example**:
- A **Personal Assistant Agent** uses the **Memory Agent** to remember details about the user’s preferences (e.g., travel plans, personal preferences), so it can provide more personalized recommendations in future interactions.

---

### **Summary of Agentic Patterns**:

- **Delegator Agent**: Distributes tasks to other agents based on expertise.
- **Mediator Agent**: Facilitates communication and resolves conflicts between


---

preceding: [[next, discuss inter-agent collaboration. introduce the fact-checker agentic programming pattern and demonstrate it.]]  


following: [[start with the delegator next]]

See also: [[information overload]]


See also: [[role separation]]