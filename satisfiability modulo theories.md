---
date: 1728115104.809574
tags:
- autogenerated
- source__oai
- conversation_id__6700f1a0-6210-8008-a0d9-19e4eecc5670
- msg_aaa2d380-24bc-46c7-956e-d69520bf34e0
- msg_93c4ca14-c299-4063-9073-5cda59dc9130
- colorclass/systems-theory
title: satisfiability modulo theories
---

**USER**

satisfiability modulo theories


**ASSISTANT**

**Satisfiability Modulo Theories (SMT)** is a generalization of the [[Boolean Satisfiability Problem (SAT)|Boolean satisfiability problem (SAT)]], extending it to domains with richer structures such as real numbers, integers, arrays, data types, and more. In essence, SMT asks whether a logical formula can be satisfied given a certain background theory (or theories) governing the symbols within the formula.

### 1. **Formal Definition**
An SMT problem is specified as:
- A logical formula $\varphi$ expressed in first-order logic, often involving functions, predicates, constants, and variables.
- A background theory $\mathcal{T}$ that constrains the interpretation of symbols within $\varphi$.

The goal is to determine if there exists an interpretation of the variables in $\varphi$ that makes it true, while respecting the constraints imposed by $\mathcal{T}$. Formally, the SMT problem can be written as:
$$
\text{SMT}(\mathcal{T}) = \{\varphi \mid \varphi \text{ is satisfiable in a model of } \mathcal{T} \}.
$$

### 2. **Theories in SMT**
A theory $\mathcal{T}$ consists of a set of axioms or rules that define a particular structure or domain. Some common theories used in SMT include:

- **Linear Arithmetic over Reals (LRA)**: Deals with linear inequalities over real numbers. For example, $\forall x, y \in \mathbb{R}$, the expressions $2x + 3y \leq 5$ and $x - y \geq 0$ belong to this theory.
  
- **Linear Arithmetic over Integers (LIA)**: Similar to LRA but for integer variables. E.g., $3x + 2 \leq 0$, where $x \in \mathbb{Z}$.

- **Arrays**: Models arrays with operations like read (`select`) and write (`store`). For example, for an array $A$, the expression $\text{select}(\text{store}(A, i, v), j) = v$ if $i = j$.
  
- **Bit-vectors**: Common in hardware verification, involving fixed-length binary words and bitwise operations.

- **Uninterpreted Functions (EUF)**: Allows the use of functions without defining their exact behavior, relying only on their properties. For instance, the function $f(x)$ might have the property $f(a) = f(b) \implies a = b$ but not specify $f$â€™s internal workings.

An SMT solver can be equipped to handle multiple theories at once, which enables it to tackle highly complex problems involving different domains.

### 3. **SMT vs. SAT**
While SAT problems deal with purely Boolean variables and propositional logic, SMT extends SAT to include various theories. Essentially, an SMT problem can be seen as a SAT problem augmented with additional constraints from the underlying theory $\mathcal{T}$. If the theory is trivial (e.g., there are no non-Boolean constraints), the SMT problem reduces to a standard SAT problem.

### 4. **SMT Solving Techniques**
SMT solvers employ various strategies to handle the interaction between the Boolean structure of the formula and the theory constraints. Some of the key techniques include:

#### 4.1 **DPLL(T) Framework**
A widely-used approach for SMT solving, DPLL(T) integrates the classical Davis-Putnam-Logemann-Loveland (DPLL) algorithm for SAT solving with a theory solver $T$. The algorithm works as follows:

1. **Boolean Abstraction**: The SMT problem is first abstracted into a purely Boolean formula, ignoring the theory constraints.
2. **SAT Solving**: A SAT solver checks if this Boolean abstraction is satisfiable.
3. **Theory Propagation**: If satisfiable, the solution is checked against the theory $\mathcal{T}$ using a dedicated theory solver.
4. **Conflict Resolution**: If the theory constraints are violated, the algorithm backtracks and learns new clauses to avoid the conflict, similar to conflict-driven clause learning (CDCL) in SAT solving.

#### 4.2 **Nelson-Oppen Method**
For problems involving multiple theories, the Nelson-Oppen approach can be used, which works under the following conditions:
- The theories involved must be **stably infinite**, meaning any satisfiable formula has an infinite model.
- The theories should be **signature-disjoint**, i.e., they do not share common symbols.

The Nelson-Oppen procedure communicates equalities between shared variables across different theory solvers to achieve a consistent solution.

### 5. **Applications of SMT**
SMT solvers are powerful tools in many areas, including:
- **Software Verification**: Used to verify properties of programs, such as checking array bounds, verifying data structure invariants, and ensuring correct usage of pointers.
- **Hardware Verification**: In analyzing circuit designs, SMT solvers handle bit-vectors and arithmetic properties to verify correctness.
- **Constraint Solving**: Employed in planning, scheduling, and optimization problems where constraints arise naturally.
- **Synthesis**: Used in program synthesis and automated generation of inputs that satisfy certain properties.

### 6. **Popular SMT Solvers**
Some state-of-the-art SMT solvers include:
- **Z3**: Developed by Microsoft Research, supporting numerous theories like arithmetic, bit-vectors, arrays, and more.
- **CVC4**: Capable of handling a wide range of theories, including those involving quantifiers.
- **Yices**: Focuses on providing efficient solving for combinations of theories.

### 7. **Example of an SMT Problem**
Consider the formula:
$$
\varphi: (x \geq 0) \land (y \geq 0) \land (x + y \geq 10) \land (x \leq 5).
$$
In the theory of linear arithmetic over the reals (LRA), an SMT solver will check if there exist real numbers $x$ and $y$ satisfying all the constraints. In this case, the formula is **satisfiable** with solutions like $x = 5, y = 5$. However, if the formula is modified to include a theory constraint from integer arithmetic (LIA), e.g., $x, y \in \mathbb{Z}$, the solver would find integer solutions such as $x = 5, y = 5$.

SMT extends the capabilities of SAT by allowing the incorporation of complex, domain-specific reasoning through the inclusion of theories, making it a versatile tool in formal verification and constraint satisfaction problems.


---


following: [[smt vs. cp-sat]]