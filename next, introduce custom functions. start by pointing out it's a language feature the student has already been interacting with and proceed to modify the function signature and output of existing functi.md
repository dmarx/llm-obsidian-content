---
date: 1726440462.674732
tags:
- autogenerated
- source__oai
- conversation_id__66e757d1-0534-8008-bb6a-afa8342b5ee2
- msg_a891def5-b53b-44ae-bbad-01e1d4c0c55b
- msg_aaa296d8-9e5c-4488-bcf1-5dd1dfd5d322
- msg_1067f736-6978-4497-9ea1-1ac221e798c2
- colorclass/edge-case
title: next, introduce custom functions. start by pointing out it's a language feature
  the student has already been interacting with and proceed to modify the function
  signature and output of existing functi
---

**ASSISTANT**

:

In future lessons, you could expand on Jinja2 templating by introducing more advanced features:
- **Conditionals**: Use `if-else` in the template to generate optional sections of the prompt.
- **Loops**: Dynamically generate multiple parts of a prompt by iterating over a list in the template.

---

### **Summary**:

This assignment introduces students to the **limitations of manual string substitution** and demonstrates how **Jinja2 templating** simplifies the process. By showing both approaches, students can appreciate the benefits of templating for more complex prompt engineering tasks, while understanding that they already have the foundational tools to do dynamic text generation.


**USER**

next, introduce custom functions. start by pointing out it's a language feature the student has already been interacting with and proceed to modify the function signature and output of existing functions. illustrate **kwargs (don't discuss *args) and completely skip over why it works, just show the student how to use it to propagate arguments in nested functions.


**ASSISTANT**

Great! We'll introduce **custom functions** by showing students that they’ve already been interacting with functions—like `query_gpt`—and how they can modify and extend them. Then, we’ll add functionality to an existing function and introduce **`**kwargs`** as a way to pass additional arguments, especially when dealing with nested function calls. We’ll keep it practical, showing how `**kwargs` helps propagate arguments without getting into why it works.

---

### **Eighth Assignment: Introducing Custom Functions and `**kwargs`**

### **Objective**:
1. Show students that they’ve already been using custom functions and can modify or create their own.
2. Modify the signature and output of existing functions to extend functionality.
3. Introduce **`**kwargs`** to propagate arguments in nested functions, focusing on how it’s used without getting into the details of how it works.

### **Concept**:
We’ll build on the previous assignment by modifying the `query_gpt` function to accept additional options, showing how students can add or modify functions they’re already using. Then, we’ll introduce `**kwargs` to allow the passing of extra parameters through multiple layers of function calls, without needing to explicitly list all the parameters at each level.

---

### **Step 1: Recognizing Functions You've Already Used**

#### **Pointing Out Custom Functions**:
Start by explaining that students have already been interacting with **custom functions**. For example, the `query_gpt` function is a custom function defined to encapsulate the logic for calling the OpenAI API. It takes specific inputs like `prompts` and `max_tokens` and returns a response from the API.

Here’s the function they’ve already seen:
```python
def query_gpt(prompts, max_tokens=50, temperature=0.7, top_p=1.0):
    openai.api_key = api_key
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompts,
        max_tokens=max_tokens,
        temperature=temperature,
        top_p=top_p,
    )
    return response
```

#### **Modifying the Function Signature**:
We can show that functions are flexible—students can modify them to add functionality or change behavior.

For example, what if we wanted to change the `query_gpt` function to return a more formatted response, or to include more options? Let’s say we want to add an optional `verbose` flag that prints extra information during the API call.

---

### **Step 2: Modifying the Function Signature**

Here’s the updated version of `query_gpt` with the `verbose` flag. When `verbose=True`, it prints additional debugging information (e.g., the prompts being sent and the response from the API).

```python
import openai

# Modified query_gpt function with an optional 'verbose' flag
def query_gpt(prompts, max_tokens=50, temperature=0.7, top_p=1.0, verbose=False):
    """
    Function to query the OpenAI API with given prompts and optional verbosity.

    Arguments:
    - prompts: List of prompts to send to the API.
    - max_tokens: Maximum number of tokens to generate.
    - temperature: Controls randomness in the output.
    - top_p: Controls diversity of word choices.
    - verbose: If True, prints extra information about the API request.
    """
    # Print debug information if verbose mode is enabled
    if verbose:
        print("Sending the following prompts to the API:")
        for prompt in prompts:
            print(f"- {prompt}")
    
    # Make the API call
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompts,
        max_tokens=max_tokens,
        temperature=temperature,
        top_p=top_p,
    )
    
    # Print the response if verbose mode is enabled
    if verbose:
        print("\nReceived response from API:")
        print(response)
    
    return response
```

---

### **Step 3: Introducing `**kwargs` for Flexibility**

Now, let’s take this further. In complex applications, you may have nested functions where different options need to be passed around without explicitly listing all of them in the function signature every time. This is where `**kwargs` can make your life easier.

#### **Using `**kwargs` to Propagate Extra Arguments**:

Here’s an example where we modify the function to accept `**kwargs`, allowing us to pass extra options to the `openai.Completion.create()` call without explicitly defining them in the function signature.

This gives the student flexibility to add options like `logprobs`, `stop`, or other OpenAI API parameters in the future without having to modify every function.

```python
import openai

# Modified query_gpt function using **kwargs to pass additional options
def query_gpt(prompts, max_tokens=50, temperature=0.7, top_p=1.0, verbose=False, **kwargs):
    """
    Function to query the OpenAI API with given prompts and optional verbosity.
    Supports additional arguments through **kwargs.

    Arguments:
    - prompts: List of prompts to send to the API.
    - max_tokens: Maximum number of tokens to generate.
    - temperature: Controls randomness in the output.
    - top_p: Controls diversity of word choices.
    - verbose: If True, prints extra information about the API request.
    - **kwargs: Additional options to pass to the OpenAI API.
    """
    # Print debug information if verbose mode is enabled
    if verbose:
        print("Sending the following prompts to the API:")
        for prompt in prompts:
            print(f"- {prompt}")
    
    # Make the API call, passing along any extra options via **kwargs
    response = openai.Completion.create(
        model="text-davinci-003",
        prompt=prompts,
        max_tokens=max_tokens,
        temperature=temperature,
        top_p=top_p,
        **kwargs  # Pass additional arguments
    )
    
    # Print the response if verbose mode is enabled
    if verbose:
        print("\nReceived response from API:")
        print(response)
    
    return response
```

---

### **Step 4: Using `**kwargs` in Nested Functions**

We can now demonstrate how `**kwargs` works when passed through multiple layers of functions.

Here’s an example of how to use `**kwargs` to propagate arguments from one function to another:

```python
# A wrapper function that uses query_gpt
def generate_prompts_and_query(city="Paris", year="2023", verbose=False, **kwargs):
    """
    Function that generates prompts and calls query_gpt with additional options.

    Arguments:
    - city: The city name to replace in the template.
    - year: The year to replace in the template.
    - verbose: If True, prints extra information.
    - **kwargs: Additional options to pass to query_gpt.
    """
    # Define a list of prompts with placeholders
    prompts = [
        f"What major events happened in {city} in {year}?",
        f"How has the population of {city} changed since {year}?",
        f"What are some famous landmarks in {city}?",
    ]
    
    # Call query_gpt, passing **kwargs along to handle extra options
    response = query_gpt(prompts, verbose=verbose, **kwargs)
    
    return response

# Example usage
response = generate_prompts_and_query(city="London", year="2022", verbose=True, max_tokens=100)
```

### **How `**kwargs` Works Here**:
1. **`generate_prompts_and_query`**: This function generates prompts and calls `query_gpt`.
2. **`query_gpt`**: This function accepts and propagates any extra arguments passed via `**kwargs`, allowing flexibility without needing to modify both function signatures for every new option.

In this example, `max_tokens=100` is passed from `generate_prompts_and_query` to `query_gpt` through `**kwargs`. If new options are added later (e.g., `stop` or `logprobs`), we won’t need to update the function signature each time.

---

### **Running the Script**:

To run the script with extra arguments:
```bash
python script.py --city "Tokyo" --year "2021" --verbose True --max_tokens 100
```

This will send the specified prompts to the OpenAI API, allowing for additional API parameters like `max_tokens`.

---

### **Why Use `**kwargs`?**
- **Flexibility**: `**kwargs` allows students to pass additional arguments without explicitly listing them in the function signature.
- **Propagation**: In nested functions, `**kwargs` enables passing arguments from one function to another without modifying every function that might use these options.
- **Simplicity**: You don’t have to update multiple function signatures whenever you need to pass a new argument.

---

### **Learning Outcomes**:

1. **Custom Functions**: Students will learn how to modify and extend existing functions, allowing for more complex behavior and outputs.
2. **Optional Parameters**: Introducing optional parameters (like `verbose`) shows how students can make functions more flexible.
3. **Using `**kwargs`**: Without diving into why it works, students will understand how to use `**kwargs` to pass additional arguments and propagate options through nested function calls, making their code more adaptable.

---

### **Summary**:

This assignment teaches students how to work with **custom functions**, demonstrating that they’ve already been using them, and showing how they can extend these functions with additional parameters. By introducing `**kwargs`, students will learn how to propagate arguments in nested functions, making their code more flexible and modular, without getting bogged down in the details


---

preceding: [[openai completions object actually has a much nicer repr than that, here's an example]]  


following: [[introduce classes through the context of a simple `agent` abstraction, where we assign each agent a system prompt and a name, and use  jinja to resolve each respective agent's system prompt]]